{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Oxyde ORM","text":"<p> Oxyde ORM is a type-safe, Pydantic-centric asynchronous ORM with a high-performance Rust core designed for clarity, speed, and reliability. </p> <p> Inspired by the elegance of Django\u2019s ORM, Oxyde focuses on explicitness over magic, providing a modern developer-friendly workflow with predictable behavior and strong typing throughout. </p> <p> </p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p> Installation</p> <p>Install Oxyde and set up your environment</p> <p> Getting started</p> </li> <li> <p> Quick Start</p> <p>Build your first app in 5 minutes</p> <p> Quick start</p> </li> <li> <p> Guide</p> <p>Learn Oxyde step by step</p> <p> User guide</p> </li> <li> <p> API Reference</p> <p>Complete API documentation</p> <p> Cheatsheet</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Django-style API \u2014 Familiar <code>Model.objects.filter()</code> syntax</li> <li>Pydantic v2 models \u2014 Full validation, type hints, serialization</li> <li>Async-first \u2014 Built for modern async Python with <code>asyncio</code></li> <li>Rust performance \u2014 SQL generation and execution in native Rust</li> <li>Multi-database \u2014 PostgreSQL, SQLite, MySQL support</li> <li>Transactions \u2014 <code>transaction.atomic()</code> context manager with savepoints</li> <li>Migrations \u2014 Django-style <code>makemigrations</code> and <code>migrate</code> CLI</li> </ul>"},{"location":"#why-oxyde","title":"Why Oxyde?","text":""},{"location":"#performance","title":"Performance","text":"<p>Oxyde's Rust core handles SQL generation and query execution, releasing Python's GIL during database I/O. This enables true parallelism for database operations.</p> <p>Benchmarks vs popular Python ORMs (avg ops/sec, higher is better):</p> Database Oxyde Tortoise Piccolo SQLAlchemy SQLModel Peewee Django PostgreSQL 924 748 746 336 324 61 59 MySQL 1037 1019 \u2014 434 420 371 313 SQLite 1232 1477 295 342 336 449 434 <p> Full benchmark report</p>"},{"location":"#type-safety","title":"Type Safety","text":"<p>Built on Pydantic v2, Oxyde provides full type checking for models and queries. Your IDE understands your database schema.</p>"},{"location":"#familiar-api","title":"Familiar API","text":"<p>If you know Django ORM, you know Oxyde. The QuerySet API follows Django conventions:</p> <pre><code># Django\nUser.objects.filter(age__gte=18).exclude(status=\"banned\").order_by(\"-created_at\")\n\n# Oxyde (identical)\nawait User.objects.filter(age__gte=18).exclude(status=\"banned\").order_by(\"-created_at\").all()\n</code></pre>"},{"location":"#async-native","title":"Async Native","text":"<p>No sync wrappers or thread pools. Oxyde is async from the ground up:</p> <pre><code>from oxyde.db import transaction\n\nasync with transaction.atomic():\n    user = await User.objects.create(name=\"Alice\")\n    await Profile.objects.create(user_id=user.id)\n</code></pre>"},{"location":"#database-support","title":"Database Support","text":"Database Min Version Status Notes PostgreSQL 12+ Full RETURNING, UPSERT, FOR UPDATE/SHARE, JSON, Arrays SQLite 3.35+ Full RETURNING, UPSERT, WAL mode by default MySQL 8.0+ Full UPSERT via ON DUPLICATE KEY, FOR UPDATE/SHARE <p>SQLite &lt; 3.35: Falls back to <code>last_insert_rowid()</code> which may return incorrect IDs with concurrent inserts.</p> <p>MySQL: No RETURNING clause \u2014 uses <code>last_insert_id()</code>. Bulk INSERT returns calculated ID range which may be incorrect with concurrent inserts.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Oxyde are documented here.</p>"},{"location":"changelog/#040","title":"0.4.0","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/#oxydemodel-renamed-to-model","title":"<code>OxydeModel</code> renamed to <code>Model</code>","text":"<p>The base class has been renamed from <code>OxydeModel</code> to <code>Model</code>:</p> <pre><code># Before (0.3.x)\nfrom oxyde import OxydeModel\n\nclass User(OxydeModel):\n    ...\n\n# After (0.4.0+)\nfrom oxyde import Model\n\nclass User(Model):\n    ...\n</code></pre> <p>Deprecation notice</p> <p><code>OxydeModel</code> still works in 0.4.x and emits a <code>DeprecationWarning</code>. It will be removed in a future release. Update your imports now:</p> <pre><code># Find and replace across your project:\nOxydeModel \u2192 Model\n</code></pre> <p>Direct import <code>from oxyde.models.base import OxydeModel</code> is not supported and will raise <code>ImportError</code>.</p>"},{"location":"changelog/#limit-and-offset-reject-negative-values","title":"<code>limit()</code> and <code>offset()</code> reject negative values","text":"<p>Both methods now raise <code>ValueError</code> on negative input. Previously negative values were silently accepted and produced invalid SQL.</p> <pre><code># 0.3.x: silently generated broken SQL\nqs.limit(-1)\n\n# 0.4.0: raises ValueError\nqs.limit(-1)  # ValueError: limit() requires a non-negative value, got -1\n</code></pre>"},{"location":"changelog/#ensure_field_metadata-removed","title":"<code>ensure_field_metadata()</code> removed","text":"<p>The classmethod <code>Model.ensure_field_metadata()</code> has been removed. Model metadata is now finalized eagerly at class definition time. If you were calling this method manually, simply remove the call \u2014 it is no longer needed.</p>"},{"location":"changelog/#resolve_pending_fk-replaced","title":"<code>resolve_pending_fk()</code> replaced","text":"<p><code>resolve_pending_fk()</code> in <code>oxyde.models.registry</code> has been replaced by:</p> <ul> <li><code>finalize_pending()</code> \u2014 eagerly finalizes all pending models</li> <li><code>assert_no_pending_models()</code> \u2014 raises <code>RuntimeError</code> if any models are still pending</li> </ul>"},{"location":"changelog/#migrationstypes-module-removed","title":"<code>migrations.types</code> module removed","text":"<p>The <code>oxyde.migrations.types</code> module (<code>validate_sql_type</code>, <code>normalize_sql_type</code>, <code>translate_db_specific_type</code>) has been removed. Type handling is now internal to the Rust core.</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li><code>union()</code> / <code>union_all()</code> were silently ignored \u2014 union queries now correctly generate SQL and execute as expected.</li> <li>FK relation fields included in INSERT/UPDATE \u2014 fields like <code>author: Author</code> were incorrectly serialized into INSERT/UPDATE statements alongside the actual <code>author_id</code> column. Now properly excluded.</li> <li>Nested JOIN hydration failed \u2014 deeply nested joins (e.g. <code>post__author__profile</code>) could produce incorrect or missing data. Hydration logic rewritten to correctly resolve nested FK references.</li> <li><code>get_or_create()</code> race condition \u2014 concurrent calls creating the same record could both fail with <code>IntegrityError</code>. Now retries <code>get()</code> on conflict.</li> <li>Migration advisory lock on wrong connection \u2014 <code>pg_try_advisory_lock</code> and <code>pg_advisory_unlock</code> could execute on different pool connections. Lock now pins a connection via <code>begin_transaction()</code>.</li> <li>Transaction leak on savepoint failure \u2014 if savepoint creation failed, transaction depth was already incremented, corrupting state. Depth is now incremented only after successful savepoint creation.</li> <li><code>bulk_create([])</code> did not raise \u2014 empty list was silently accepted. Now correctly raises <code>ValueError</code>.</li> <li>Negative pool duration accepted \u2014 <code>PoolSettings</code> durations now raise <code>ValueError</code> for negative values.</li> <li><code>makemigrations</code> silently continued on broken migrations \u2014 if replaying existing migrations failed, the CLI used an empty schema as baseline, potentially generating destructive migrations. Now fails with exit code 1.</li> <li><code>migrate</code> wrong exit code \u2014 <code>migrate</code> could exit with code 0 when migration was not found.</li> </ul>"},{"location":"changelog/#improvements","title":"Improvements","text":"<ul> <li>Eager model finalization \u2014 model metadata (field metadata, column types, PK info) is now computed at class definition time instead of lazily on first query. Eliminates an entire class of \"metadata not ready\" bugs.</li> <li>Unified type registry \u2014 <code>TYPE_REGISTRY</code> in <code>oxyde.core.types</code> consolidates all Python-to-IR type mappings. Fixes <code>bool</code> being misclassified as <code>int</code> in lookups.</li> <li>Local imports removed \u2014 circular dependency issues resolved; all imports are now at module level for better readability and faster import time.</li> </ul>"},{"location":"cheatsheet/","title":"API Cheatsheet","text":"<p>Complete API reference.</p> Method Example Returns Notes Instance Methods <code>save()</code> <code>await user.save()</code> <code>Self</code> <code>update_fields</code> for partial <code>delete()</code> <code>await user.delete()</code> <code>int</code> Delete instance <code>refresh()</code> <code>await user.refresh()</code> <code>Self</code> Reload from DB <code>pre_save()</code> override \u2014 Hook; <code>is_create</code>, <code>update_fields</code> <code>post_save()</code> override \u2014 Hook; <code>is_create</code>, <code>update_fields</code> <code>pre_delete()</code> override \u2014 Hook before delete <code>post_delete()</code> override \u2014 Hook after delete Manager Methods <code>create()</code> <code>User.objects.create(name=\"John\")</code> <code>Model</code> Insert + return <code>bulk_create()</code> <code>User.objects.bulk_create([...])</code> <code>list[Model]</code> Bulk INSERT <code>bulk_update()</code> <code>User.objects.bulk_update([...], [\"age\"])</code> <code>int</code> Bulk UPDATE <code>get()</code> <code>User.objects.get(id=42)</code> <code>Model</code> Raises if 0 or &gt;1 <code>get_or_none()</code> <code>User.objects.get_or_none(id=42)</code> <code>Model | None</code> None if not found <code>get_or_create()</code> <code>User.objects.get_or_create(email=\"...\")</code> <code>(Model, bool)</code> Atomic <code>count()</code> <code>User.objects.count()</code> <code>int</code> Count all Query Builder <code>filter()</code> <code>.filter(is_active=True, age__gte=18)</code> <code>Query</code> WHERE conditions <code>exclude()</code> <code>.exclude(status=\"banned\")</code> <code>Query</code> WHERE NOT <code>order_by()</code> <code>.order_by(\"-created_at\")</code> <code>Query</code> ORDER BY <code>limit()</code> <code>.limit(10)</code> <code>Query</code> LIMIT <code>offset()</code> <code>.offset(20)</code> <code>Query</code> OFFSET <code>prefetch()</code> <code>.prefetch(\"posts\")</code> <code>Query</code> Load reverse FK/M2M <code>join()</code> <code>.join(\"author\")</code> <code>Query</code> FK JOIN <code>distinct()</code> <code>.distinct()</code> <code>Query</code> DISTINCT <code>group_by()</code> <code>.group_by(\"status\")</code> <code>Query</code> GROUP BY <code>having()</code> <code>.having(count__gte=5)</code> <code>Query</code> HAVING <code>annotate()</code> <code>.annotate(n=Count(\"posts\"))</code> <code>Query</code> Computed fields <code>union()</code> <code>.union(other_qs)</code> <code>Query</code> UNION <code>for_update()</code> <code>.for_update()</code> <code>Query</code> Row lock <code>values()</code> <code>.values(\"id\", \"name\")</code> <code>Query</code> Result as dicts <code>values_list()</code> <code>.values_list(\"id\", flat=True)</code> <code>Query</code> Result as tuples/list Terminal Methods <code>all()</code> <code>await qs.all()</code> <code>list[Model]</code> Execute SELECT <code>first()</code> <code>await qs.first()</code> <code>Model | None</code> First row <code>last()</code> <code>await qs.last()</code> <code>Model | None</code> Last row <code>count()</code> <code>await qs.count()</code> <code>int</code> COUNT(*) <code>exists()</code> <code>await qs.exists()</code> <code>bool</code> EXISTS check <code>delete()</code> <code>await qs.delete()</code> <code>int</code> Bulk DELETE <code>update()</code> <code>await qs.update(status=\"x\")</code> <code>list[dict]</code> Bulk UPDATE (RETURNING *) <code>increment()</code> <code>await qs.increment(\"views\", by=1)</code> <code>int</code> Atomic increment <code>sum()</code> <code>await qs.sum(\"views\")</code> <code>number</code> SUM <code>avg()</code> <code>await qs.avg(\"age\")</code> <code>float</code> AVG <code>max()</code> <code>await qs.max(\"price\")</code> <code>Any</code> MAX <code>min()</code> <code>await qs.min(\"price\")</code> <code>Any</code> MIN Debug &amp; Introspection <code>sql()</code> <code>qs.sql()</code> <code>(str, list)</code> SQL + params <code>query()</code> <code>qs.query()</code> <code>dict</code> Query IR <code>explain()</code> <code>await qs.explain(analyze=True)</code> <code>str</code> Query plan Expressions <code>Q</code> <code>Q(age__gte=18) &amp; Q(status=\"active\")</code> \u2014 AND/OR/NOT <code>F</code> <code>F(\"views\") + 1</code> \u2014 Field reference <code>Count</code> <code>Count(\"posts\")</code> \u2014 Aggregate <code>Sum/Avg/Max/Min</code> <code>Sum(\"amount\")</code> \u2014 Aggregates <code>Concat</code> <code>Concat(\"first\", \"last\")</code> \u2014 String concat <code>Coalesce</code> <code>Coalesce(\"nick\", \"name\")</code> \u2014 First non-NULL <code>RawSQL</code> <code>RawSQL(\"LOWER(name)\")</code> \u2014 Raw SQL Transactions <code>transaction.atomic()</code> <code>async with transaction.atomic(): ...</code> \u2014 Nested savepoints"},{"location":"cheatsheet/#examples","title":"Examples","text":""},{"location":"cheatsheet/#basic-operations","title":"Basic Operations","text":"<pre><code># Simple query\nusers = await User.objects.filter(is_active=True, age__gte=18).all()\n\n# With prefetch and ordering\nusers = await User.objects \\\n    .prefetch(\"posts\") \\\n    .filter(is_active=True) \\\n    .order_by(\"-created_at\") \\\n    .limit(10) \\\n    .all()\n\n# Join for FK\nposts = await Post.objects.join(\"author\").filter(status=\"draft\").all()\n\n# Get single object\nuser = await User.objects.get(id=42)\nuser = await User.objects.get_or_none(email=\"test@test.com\")\n</code></pre>"},{"location":"cheatsheet/#complex-conditions","title":"Complex Conditions","text":"<pre><code># Q expressions\nusers = await User.objects.filter(\n    Q(age__gte=18) &amp; (Q(status=\"active\") | Q(status=\"premium\"))\n).all()\n\n# Exclusion\nusers = await User.objects.exclude(status=\"banned\").all()\n</code></pre>"},{"location":"cheatsheet/#create","title":"Create","text":"<pre><code># Simple create\nuser = await User.objects.create(name=\"John\", age=25)\n\n# Get or create\nuser, created = await User.objects.get_or_create(\n    email=\"test@test.com\",\n    defaults={\"name\": \"John\", \"age\": 25}\n)\n\n# Bulk create\nusers = await User.objects.bulk_create([\n    User(name=\"John\", age=25),\n    User(name=\"Jane\", age=30),\n])\n</code></pre>"},{"location":"cheatsheet/#update","title":"Update","text":"<pre><code># Instance update (full UPDATE)\nuser.age = 26\nawait user.save()\n\n# Partial update via Query (returns updated rows)\nrows = await User.objects.filter(is_active=False).update(status=\"archived\")\n\n# Atomic update with F()\nrows = await User.objects.filter(id=42).update(views=F(\"views\") + 1)\n\n# Atomic increment\ncount = await Post.objects.filter(id=42).increment(\"views\", by=1)\n\n# Bulk update\ncount = await User.objects.bulk_update(\n    [user1, user2, user3],\n    fields=[\"status\", \"updated_at\"]\n)\n</code></pre>"},{"location":"cheatsheet/#delete","title":"Delete","text":"<pre><code># Instance delete\nawait user.delete()\n\n# Bulk delete via Query\ncount = await User.objects.filter(is_active=False).delete()\n</code></pre>"},{"location":"cheatsheet/#aggregation","title":"Aggregation","text":"<pre><code># Annotate - add computed fields\nusers = await User.objects \\\n    .annotate(posts_count=Count(\"posts\")) \\\n    .filter(posts_count__gt=5) \\\n    .all()\n\n# Group by + having\nstats = await Post.objects \\\n    .group_by(\"status\") \\\n    .annotate(count=Count(\"id\"), avg_views=Avg(\"views\")) \\\n    .having(count__gte=10) \\\n    .all()\n\n# Terminal aggregates\ntotal_views = await Post.objects.filter(status=\"published\").sum(\"views\")\navg_age = await User.objects.filter(is_active=True).avg(\"age\")\nmax_price = await Product.objects.max(\"price\")\n</code></pre>"},{"location":"cheatsheet/#count-exists","title":"Count &amp; Exists","text":"<pre><code># Count with filters\ncount = await User.objects.filter(is_active=True).count()\n\n# Count all\ncount = await User.objects.count()\n\n# Exists (faster than count for existence check)\nhas_active = await User.objects.filter(is_active=True).exists()\n</code></pre>"},{"location":"cheatsheet/#values-values-list","title":"Values &amp; Values List","text":"<pre><code># Dictionaries instead of models (values is a builder, requires .all())\nusers_data = await User.objects.filter(is_active=True).values(\"id\", \"name\", \"email\").all()\n# [{\"id\": 1, \"name\": \"John\", \"email\": \"...\"}, ...]\n\n# Flat list\nuser_ids = await User.objects.filter(is_active=True).values_list(\"id\", flat=True).all()\n# [1, 2, 3, 4, ...]\n\n# Tuples\nuser_pairs = await User.objects.values_list(\"id\", \"name\").all()\n# [(1, \"John\"), (2, \"Jane\"), ...]\n</code></pre>"},{"location":"cheatsheet/#advanced-queries","title":"Advanced Queries","text":"<pre><code># Union\nactive = User.objects.filter(status=\"active\")\npremium = User.objects.filter(status=\"premium\")\ncombined = await active.union(premium).all()\n\n# Distinct\nunique_statuses = await Post.objects.distinct().values_list(\"status\", flat=True).all()\n\n# First / Last\nnewest = await Post.objects.order_by(\"-created_at\").first()\noldest = await Post.objects.order_by(\"created_at\").first()\n</code></pre>"},{"location":"cheatsheet/#transactions","title":"Transactions","text":"<pre><code>from oxyde.db import transaction\n\n# Django-style atomic transactions\nasync with transaction.atomic():\n    user = await User.objects.create(name=\"John\")\n    await Post.objects.create(author_id=user.id, title=\"First post\")\n    # Rollback on exception\n\n# Nested transactions (savepoints)\nasync with transaction.atomic():\n    user = await User.objects.create(name=\"John\")\n    async with transaction.atomic():  # Creates savepoint\n        await Post.objects.create(author_id=user.id, title=\"First post\")\n</code></pre>"},{"location":"cheatsheet/#introspection","title":"Introspection","text":"<pre><code># Get SQL query\nqs = User.objects.filter(age__gte=18).order_by(\"-created_at\")\nsql, params = qs.sql()\nprint(f\"SQL: {sql}\")\nprint(f\"Params: {params}\")\n\n# Get query IR (Intermediate Representation)\nir = qs.query()\nprint(ir)\n\n# Execution plan\nplan = await qs.explain()\nprint(plan)\n\n# With analyze\nplan = await qs.explain(analyze=True)\n</code></pre>"},{"location":"cheatsheet/#multiple-databases","title":"Multiple Databases","text":"<pre><code># Use replica for reading\nusers = await User.objects.filter(is_active=True).all(using=\"replica\")\n\n# Write to master\nuser = await User.objects.create(name=\"John\", using=\"master\")\n</code></pre>"},{"location":"cheatsheet/#lookup-operators","title":"Lookup Operators","text":"Lookup Description Example <code>field</code> Equality <code>age=18</code> <code>field__exact</code> Exact equality (same as <code>=</code>) <code>name__exact=\"John\"</code> <code>field__iexact</code> Case-insensitive equality <code>email__iexact=\"TEST@EXAMPLE.COM\"</code> <code>field__contains</code> Contains (LIKE '%...%') <code>name__contains=\"oh\"</code> <code>field__icontains</code> Case-insensitive contains <code>name__icontains=\"OH\"</code> <code>field__startswith</code> Starts with <code>name__startswith=\"Jo\"</code> <code>field__istartswith</code> Case-insensitive starts with <code>name__istartswith=\"jo\"</code> <code>field__endswith</code> Ends with <code>email__endswith=\"@example.com\"</code> <code>field__iendswith</code> Case-insensitive ends with <code>email__iendswith=\"@EXAMPLE.COM\"</code> <code>field__gt</code> Greater than (&gt;) <code>age__gt=18</code> <code>field__gte</code> Greater than or equal (&gt;=) <code>age__gte=18</code> <code>field__lt</code> Less than (&lt;) <code>age__lt=65</code> <code>field__lte</code> Less than or equal (&lt;=) <code>age__lte=65</code> <code>field__in</code> In list <code>status__in=[\"active\", \"premium\"]</code> <code>field__isnull</code> NULL check <code>deleted_at__isnull=True</code> <code>field__range</code> Between (BETWEEN) <code>age__range=(18, 65)</code> <code>field__between</code> Alias for range <code>age__between=(18, 65)</code> <code>field__year</code> Year from date <code>created_at__year=2024</code> <code>field__month</code> Month from date <code>created_at__month=(2024, 12)</code> <code>field__day</code> Day from date <code>created_at__day=(2024, 12, 25)</code>"},{"location":"cheatsheet/#best-practices","title":"Best Practices","text":""},{"location":"cheatsheet/#do","title":"DO","text":"<pre><code># Reuse Query for multiple operations\nactive = User.objects.filter(is_active=True)\ncount = await active.count()\nusers = await active.all()\n\n# Use bulk operations for performance\nawait User.objects.bulk_create([user1, user2, user3])\n\n# Use prefetch to load related objects\nusers = await User.objects.prefetch(\"posts\").all()\n\n# Use F() for atomic updates\nawait Post.objects.filter(id=42).update(views=F(\"views\") + 1)\n\n# Check existence with exists(), not count()\nif await User.objects.filter(email=email).exists():\n    ...\n</code></pre>"},{"location":"cheatsheet/#dont","title":"DON'T","text":"<pre><code># Don't query in a loop\nusers = await User.objects.all()\nfor user in users:\n    posts = await Post.objects.filter(author_id=user.id).all()  # \u274c Multiple queries\n\n# Use prefetch instead:\nusers = await User.objects.prefetch(\"posts\").all()  # \u2705 Two queries total\n\n# Don't save() in a loop for bulk updates\nfor user in users:\n    user.status = \"archived\"\n    await user.save()  # \u274c\n\n# Use bulk_update or update():\nawait User.objects.filter(id__in=ids).update(status=\"archived\")  # \u2705\n\n# Don't forget .all() for Query\nusers = await User.objects.filter(is_active=True)  # \u274c Returns Query\nusers = await User.objects.filter(is_active=True).all()  # \u2705\n</code></pre>"},{"location":"cheatsheet/#architecture-notes","title":"Architecture Notes","text":""},{"location":"cheatsheet/#query-builder-lazy-evaluation","title":"Query Builder (Lazy Evaluation)","text":"<pre><code># These methods DON'T execute SQL, they just build Query\nqs = User.objects.filter(is_active=True)  # Query object\nqs = qs.prefetch(\"posts\")                  # Query object\nqs = qs.order_by(\"-created_at\")            # Query object\n\n# SQL executes only on terminal method call\nusers = await qs.all()  # \u2190 SELECT executes here\n</code></pre>"},{"location":"cheatsheet/#prefetch-vs-join","title":"Prefetch vs Join","text":"<pre><code># join() - for FK (single query with JOIN)\nposts = await Post.objects.join(\"author\").all()\n# SQL: SELECT * FROM posts JOIN users ON ...\n\n# prefetch() - for reverse FK / M2M (separate query)\nusers = await User.objects.prefetch(\"posts\").all()\n# SQL: SELECT * FROM users;\n#      SELECT * FROM posts WHERE author_id IN (...);\n</code></pre>"},{"location":"cheatsheet/#next-steps","title":"Next Steps","text":"<ul> <li>Filtering \u2014 Filter conditions and lookups</li> <li>Models \u2014 Model definition</li> <li>Queries \u2014 Query API</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Common questions and answers about Oxyde.</p>"},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#what-is-oxyde","title":"What is Oxyde?","text":"<p>Oxyde is a high-performance async Python ORM with a Rust core. It combines:</p> <ul> <li>Python API: Pydantic v2 models with Django-style query syntax</li> <li>Rust Core: High-performance SQL generation and execution via sqlx</li> <li>MessagePack Protocol: Efficient binary communication (~2KB payloads)</li> </ul>"},{"location":"faq/#why-rust","title":"Why Rust?","text":"<p>The Rust core provides:</p> <ul> <li>Performance: SQL generation and connection pooling are 5-10x faster than pure Python</li> <li>Memory Safety: No GC pauses during I/O operations</li> <li>Concurrency: True async I/O that releases Python's GIL</li> </ul>"},{"location":"faq/#which-databases-are-supported","title":"Which databases are supported?","text":"Database Status Features PostgreSQL Full support RETURNING, JSONB, Arrays, UPSERT SQLite Full support RETURNING, WAL mode, connection pooling MySQL Full support No RETURNING (uses LAST_INSERT_ID), UPSERT via ON DUPLICATE KEY"},{"location":"faq/#is-oxyde-production-ready","title":"Is Oxyde production-ready?","text":"<p>Oxyde is suitable for production use with these considerations:</p> <ul> <li>Core CRUD operations are stable</li> <li>Advanced features (migrations, M2M) are still maturing</li> <li>Thoroughly test your specific use case</li> </ul>"},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#how-do-i-install-oxyde","title":"How do I install Oxyde?","text":"<pre><code>pip install oxyde\n</code></pre>"},{"location":"faq/#what-are-the-system-requirements","title":"What are the system requirements?","text":"<ul> <li>Python 3.10+</li> <li>No Rust compiler needed (wheels are pre-built)</li> </ul>"},{"location":"faq/#how-do-i-install-from-source","title":"How do I install from source?","text":"<pre><code># Clone repository\ngit clone https://github.com/mr-fatalyst/oxyde.git\ncd oxyde\n\n# Install Rust (if not installed)\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Build and install\ncd crates/oxyde-core-py\nmaturin develop --release\ncd ../../python\npip install -e .\n</code></pre>"},{"location":"faq/#models","title":"Models","text":""},{"location":"faq/#how-do-i-define-a-model","title":"How do I define a model?","text":"<pre><code>from oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"faq/#why-isnt-my-model-creating-a-table","title":"Why isn't my model creating a table?","text":"<p>Ensure you have <code>is_table = True</code> in the Meta class:</p> <pre><code>class User(Model):\n    class Meta:\n        is_table = True  # Required!\n</code></pre>"},{"location":"faq/#how-do-i-use-uuids-as-primary-keys","title":"How do I use UUIDs as primary keys?","text":"<pre><code>from uuid import UUID\n\nclass User(Model):\n    id: UUID = Field(\n        db_pk=True,\n        db_default=\"gen_random_uuid()\"  # PostgreSQL\n    )\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"faq/#how-do-i-add-pydantic-validation","title":"How do I add Pydantic validation?","text":"<p>Oxyde fields support all Pydantic validation:</p> <pre><code>class User(Model):\n    age: int = Field(ge=0, le=150)\n    email: str = Field(pattern=r\"^[\\w.-]+@[\\w.-]+\\.\\w+$\")\n    name: str = Field(min_length=1, max_length=100)\n</code></pre>"},{"location":"faq/#queries","title":"Queries","text":""},{"location":"faq/#how-do-i-filter-with-or-conditions","title":"How do I filter with OR conditions?","text":"<p>Use Q expressions:</p> <pre><code>from oxyde import Q\n\nusers = await User.objects.filter(\n    Q(status=\"active\") | Q(premium=True)\n).all()\n</code></pre>"},{"location":"faq/#how-do-i-do-case-insensitive-search","title":"How do I do case-insensitive search?","text":"<p>Use <code>__icontains</code>, <code>__iexact</code>, etc.:</p> <pre><code>users = await User.objects.filter(name__icontains=\"alice\").all()\nusers = await User.objects.filter(email__iexact=\"ALICE@EXAMPLE.COM\").all()\n</code></pre>"},{"location":"faq/#how-do-i-paginate-results","title":"How do I paginate results?","text":"<pre><code># Page 1 (first 20)\npage1 = await User.objects.limit(20).all()\n\n# Page 2\npage2 = await User.objects.offset(20).limit(20).all()\n\n# With ordering\nusers = await User.objects.order_by(\"-created_at\").limit(20).offset(40).all()\n</code></pre>"},{"location":"faq/#how-do-i-count-rows-efficiently","title":"How do I count rows efficiently?","text":"<pre><code># Don't do this (loads all rows)\ncount = len(await User.objects.all())\n\n# Do this instead\ncount = await User.objects.filter(status=\"active\").count()\n</code></pre>"},{"location":"faq/#how-do-i-load-related-objects","title":"How do I load related objects?","text":"<p>Use <code>join()</code> for FK relations:</p> <pre><code># Without join - author not loaded\nposts = await Post.objects.all()\nfor post in posts:\n    print(post.author)  # None - not loaded\n\n# With join - author loaded in same query\nposts = await Post.objects.join(\"author\").all()\nfor post in posts:\n    print(post.author.name)  # Data available\n</code></pre>"},{"location":"faq/#how-do-i-do-atomic-updates","title":"How do I do atomic updates?","text":"<p>Use F expressions:</p> <pre><code>from oxyde import F\n\n# Atomic increment\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\n\n# Atomic decrement\nawait User.objects.filter(id=1).update(balance=F(\"balance\") - 100)\n</code></pre>"},{"location":"faq/#connections","title":"Connections","text":""},{"location":"faq/#how-do-i-connect-to-the-database","title":"How do I connect to the database?","text":"<pre><code>from oxyde import db\n\nawait db.init(default=\"postgresql://user:pass@localhost/mydb\")\n</code></pre>"},{"location":"faq/#how-do-i-configure-connection-pooling","title":"How do I configure connection pooling?","text":"<pre><code>from oxyde import db, PoolSettings\n\nawait db.init(\n    default=\"postgresql://localhost/mydb\",\n    settings=PoolSettings(\n        max_connections=20,\n        min_connections=5,\n        acquire_timeout=30,\n    ),\n)\n</code></pre>"},{"location":"faq/#how-do-i-use-multiple-databases","title":"How do I use multiple databases?","text":"<pre><code>await db.init(\n    default=\"postgresql://localhost/main\",\n    analytics=\"postgresql://localhost/analytics\",\n)\n\n# Use specific database\nevents = await Event.objects.all(using=\"analytics\")\n</code></pre>"},{"location":"faq/#how-do-i-close-connections-properly","title":"How do I close connections properly?","text":"<pre><code>from oxyde import db\n\n# In application shutdown\nawait db.close()\n\n# With FastAPI lifespan\napp = FastAPI(lifespan=db.lifespan(default=\"postgresql://localhost/mydb\"))\n</code></pre>"},{"location":"faq/#transactions","title":"Transactions","text":""},{"location":"faq/#how-do-i-use-transactions","title":"How do I use transactions?","text":"<pre><code>from oxyde.db import transaction\n\nasync with transaction.atomic():\n    user = await User.objects.create(name=\"Alice\")\n    await Account.objects.create(user_id=user.id, balance=0)\n</code></pre>"},{"location":"faq/#what-happens-on-exception","title":"What happens on exception?","text":"<p>The transaction is automatically rolled back:</p> <pre><code>async with transaction.atomic():\n    await User.objects.create(name=\"Alice\")\n    raise ValueError(\"Oops!\")  # Transaction rolled back\n</code></pre>"},{"location":"faq/#how-do-i-use-savepoints","title":"How do I use savepoints?","text":"<p>Nest <code>transaction.atomic()</code> blocks:</p> <pre><code>async with transaction.atomic():\n    await User.objects.create(name=\"Alice\")\n\n    try:\n        async with transaction.atomic():\n            await User.objects.create(name=\"Bob\")\n            raise ValueError()  # Inner transaction rolled back\n    except ValueError:\n        pass  # Alice is still committed\n\n    await User.objects.create(name=\"Charlie\")\n</code></pre>"},{"location":"faq/#how-do-i-lock-rows","title":"How do I lock rows?","text":"<p>Use <code>for_update()</code> or <code>for_share()</code>:</p> <pre><code>from oxyde.db import transaction\n\nasync with transaction.atomic():\n    user = await User.objects.filter(id=1).for_update().first()\n    user.balance -= 100\n    await user.save()\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#why-are-my-queries-slow","title":"Why are my queries slow?","text":"<p>Common causes:</p> <ol> <li>Missing indexes: Add <code>db_index=True</code> to filtered fields</li> <li>Queries in loops: Use <code>join()</code> or <code>prefetch()</code> to load related objects</li> <li>Large result sets: Use <code>limit()</code> and pagination</li> <li>Missing connection pool: Configure <code>min_connections &gt; 0</code></li> </ol>"},{"location":"faq/#how-do-i-analyze-query-performance","title":"How do I analyze query performance?","text":"<pre><code># Get query plan\nplan = await User.objects.filter(age__gte=18).explain()\nprint(plan)\n\n# With execution times\nplan = await User.objects.filter(age__gte=18).explain(analyze=True)\n</code></pre>"},{"location":"faq/#how-do-i-see-the-generated-sql","title":"How do I see the generated SQL?","text":"<pre><code>sql, params = User.objects.filter(age__gte=18).sql()\nprint(sql)  # SELECT ... WHERE age &gt;= $1\nprint(params)  # [18]\n</code></pre>"},{"location":"faq/#what-are-the-best-sqlite-settings","title":"What are the best SQLite settings?","text":"<p>Oxyde applies optimized defaults automatically:</p> <ul> <li>WAL journal mode (10-20x faster writes)</li> <li>NORMAL synchronous mode</li> <li>10MB cache size</li> <li>5 second busy timeout</li> </ul>"},{"location":"faq/#errors","title":"Errors","text":""},{"location":"faq/#notfounderror","title":"NotFoundError","text":"<p>Raised when <code>get()</code> finds no rows:</p> <pre><code>try:\n    user = await User.objects.get(id=999)\nexcept NotFoundError:\n    print(\"User not found\")\n\n# Or use get_or_none\nuser = await User.objects.get_or_none(id=999)\n</code></pre>"},{"location":"faq/#multipleobjectsreturned","title":"MultipleObjectsReturned","text":"<p>Raised when <code>get()</code> finds multiple rows:</p> <pre><code># Wrong - status is not unique\nuser = await User.objects.get(status=\"active\")\n\n# Correct - use unique field\nuser = await User.objects.get(email=\"alice@example.com\")\n\n# Or use first() for non-unique queries\nuser = await User.objects.filter(status=\"active\").first()\n</code></pre>"},{"location":"faq/#integrityerror","title":"IntegrityError","text":"<p>Raised on constraint violations:</p> <pre><code>try:\n    await User.objects.create(email=\"duplicate@example.com\")\nexcept IntegrityError:\n    print(\"Email already exists\")\n\n# Better: use get_or_create\nuser, created = await User.objects.get_or_create(\n    email=\"alice@example.com\",\n    defaults={\"name\": \"Alice\"}\n)\n</code></pre>"},{"location":"faq/#migrations","title":"Migrations","text":""},{"location":"faq/#how-do-i-create-migrations","title":"How do I create migrations?","text":"<pre><code>oxyde makemigrations\n</code></pre>"},{"location":"faq/#how-do-i-apply-migrations","title":"How do I apply migrations?","text":"<pre><code>oxyde migrate\n</code></pre>"},{"location":"faq/#how-do-i-see-migration-status","title":"How do I see migration status?","text":"<pre><code>oxyde showmigrations\n</code></pre>"},{"location":"faq/#how-do-i-rollback-a-migration","title":"How do I rollback a migration?","text":"<pre><code>oxyde migrate 0001  # Rollback to migration 0001\n</code></pre>"},{"location":"advanced/benchmarks/","title":"Benchmarks","text":"<p>Benchmark Date</p> <p>These benchmarks were run on January 23, 2026 with Oxyde 0.3.1. Results may vary depending on hardware and database configuration.</p>"},{"location":"advanced/benchmarks/#summary-average-opssec","title":"Summary (average ops/sec)","text":""},{"location":"advanced/benchmarks/#postgresql","title":"PostgreSQL","text":"Rank ORM Avg ops/sec 1 Oxyde 923.7 2 Tortoise 747.6 3 Piccolo 745.9 4 SQLAlchemy 335.6 5 SQLModel 324.0 6 Peewee 61.0 7 Django 58.5"},{"location":"advanced/benchmarks/#mysql","title":"MySQL","text":"Rank ORM Avg ops/sec 1 Oxyde 1037.0 2 Tortoise 1019.2 3 SQLAlchemy 434.1 4 SQLModel 420.1 5 Peewee 370.5 6 Django 312.8"},{"location":"advanced/benchmarks/#sqlite","title":"SQLite","text":"Rank ORM Avg ops/sec 1 Tortoise 1476.6 2 Oxyde 1232.0 3 Peewee 449.4 4 Django 434.0 5 SQLAlchemy 341.5 6 SQLModel 336.3 7 Piccolo 295.1"},{"location":"advanced/benchmarks/#postgresql-results","title":"PostgreSQL Results","text":""},{"location":"advanced/benchmarks/#crud-operations","title":"CRUD Operations","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel insert_single 1685.7 121.8 747.7 1828.6 1748.3 111.0 684.3 insert_bulk_100 290.0 84.8 189.0 325.9 241.0 90.7 133.1 select_pk 2979.7 121.0 921.7 2275.7 2462.1 135.7 897.0 select_filter 182.6 71.2 156.7 107.5 134.6 78.5 132.7 update_single 2310.8 120.5 707.5 1854.4 1968.0 116.5 681.7 update_bulk 1515.9 114.6 680.5 1506.3 1659.3 131.3 652.6 delete_single 354.5 69.5 290.8 367.3 365.0 96.4 281.7"},{"location":"advanced/benchmarks/#query-operations","title":"Query Operations","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel filter_simple 2472.4 119.8 894.2 2230.7 2283.3 120.5 882.2 filter_complex 351.0 88.6 259.5 207.0 258.7 84.9 233.1 filter_in 340.5 113.0 491.8 572.4 651.8 83.5 450.4 order_limit 2417.8 120.2 843.7 1506.9 1900.3 113.2 849.0 aggregate_count 3516.2 119.6 964.3 2564.4 2541.0 130.9 954.1 aggregate_mixed 2587.6 110.4 857.6 1820.4 868.3 127.3 898.2"},{"location":"advanced/benchmarks/#relations","title":"Relations","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel join_simple 5.4 3.0 4.3 3.2 2.0 3.6 3.7 join_filter 5.8 3.2 4.5 3.4 2.1 3.7 3.9 prefetch_related 5.4 4.0 3.7 4.6 4.9 5.2 2.9 nested_prefetch 2.0 1.1 1.8 2.9 3.1 4.2 1.6"},{"location":"advanced/benchmarks/#concurrent-operations","title":"Concurrent Operations","text":"Concurrency Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel 10 548.6 8.7 10.0 388.2 396.2 13.8 10.0 25 247.8 3.8 5.0 153.9 168.3 5.1 4.9 50 126.8 1.9 4.6 78.8 88.8 2.6 4.5 100 64.2 0.9 4.0 40.3 44.5 1.3 3.9 200 31.3 0.5 3.1 19.7 21.6 0.6 3.0"},{"location":"advanced/benchmarks/#scalability","title":"Scalability","text":""},{"location":"advanced/benchmarks/#mysql-results","title":"MySQL Results","text":""},{"location":"advanced/benchmarks/#crud-operations_1","title":"CRUD Operations","text":"Test Oxyde Django SQLAlchemy Tortoise Peewee SQLModel insert_single 2118.9 863.3 956.6 2754.4 934.3 977.0 insert_bulk_100 481.6 241.4 155.7 365.1 236.7 123.6 select_pk 3269.4 904.6 1155.6 3350.3 925.6 1195.4 select_filter 196.3 146.3 80.7 66.3 82.4 78.2 update_single 2460.6 686.5 979.3 2556.2 947.1 917.0 update_bulk 1705.7 653.5 880.0 2011.3 828.2 878.2 delete_single 2046.8 298.0 987.0 2335.6 867.2 951.0"},{"location":"advanced/benchmarks/#query-operations_1","title":"Query Operations","text":""},{"location":"advanced/benchmarks/#relations_1","title":"Relations","text":""},{"location":"advanced/benchmarks/#concurrent-operations_1","title":"Concurrent Operations","text":""},{"location":"advanced/benchmarks/#scalability_1","title":"Scalability","text":""},{"location":"advanced/benchmarks/#sqlite-results","title":"SQLite Results","text":""},{"location":"advanced/benchmarks/#crud-operations_2","title":"CRUD Operations","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel insert_single 3046.0 589.3 670.2 1893.3 466.5 605.1 623.2 insert_bulk_100 631.6 260.4 31.9 448.3 176.4 259.4 29.6 select_pk 3252.1 1386.6 960.2 4958.9 913.6 1548.8 941.9 select_filter 175.0 181.6 161.9 76.0 109.8 70.3 137.9 update_single 3720.8 625.8 639.8 1870.0 507.4 594.7 649.3 update_bulk 2485.0 1419.5 916.8 5477.1 978.7 1703.1 925.0 delete_single 222.6 88.7 155.6 183.5 120.4 134.7 156.0"},{"location":"advanced/benchmarks/#query-operations_2","title":"Query Operations","text":""},{"location":"advanced/benchmarks/#relations_2","title":"Relations","text":""},{"location":"advanced/benchmarks/#concurrent-operations_2","title":"Concurrent Operations","text":""},{"location":"advanced/benchmarks/#scalability_2","title":"Scalability","text":""},{"location":"advanced/benchmarks/#latency-postgresql","title":"Latency (PostgreSQL)","text":""},{"location":"advanced/benchmarks/#mean-latency-ms","title":"Mean Latency (ms)","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel insert_single 0.59 8.21 1.34 0.55 0.57 9.01 1.46 select_pk 0.34 8.27 1.08 0.44 0.41 7.37 1.11 update_single 0.43 8.30 1.41 0.54 0.51 8.58 1.47"},{"location":"advanced/benchmarks/#p99-latency-ms","title":"P99 Latency (ms)","text":"Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel insert_single 1.04 23.71 2.36 0.97 0.83 24.13 2.17 select_pk 0.55 24.95 2.16 0.74 0.84 9.18 1.91 update_single 0.59 20.27 2.51 0.69 0.69 24.41 1.76"},{"location":"advanced/benchmarks/#memory-usage-postgresql","title":"Memory Usage (PostgreSQL)","text":"<p>Peak memory (MB):</p> Test Oxyde Django SQLAlchemy Tortoise Piccolo Peewee SQLModel insert_single 52.1 65.5 57.6 43.8 41.2 59.0 66.7 select_pk 58.7 71.0 63.1 48.1 46.0 64.1 69.8 join_simple 132.6 117.4 88.2 63.0 101.8 104.8 104.4 nested_prefetch 151.8 184.8 116.6 93.0 106.6 111.6 129.1"},{"location":"advanced/benchmarks/#test-environment","title":"Test Environment","text":"Parameter Value CPU Intel Core i7-11800H @ 2.30GHz Cores 2 RAM 4 GB OS Linux 6.8.0-90-generic Python 3.12.12 Container Docker"},{"location":"advanced/benchmarks/#package-versions","title":"Package Versions","text":"Package Version oxyde 0.3.1 asyncpg 0.31.0 django 6.0.1 sqlalchemy 2.0.46 tortoise-orm 0.25.3 piccolo 1.30.0 peewee 3.19.0 sqlmodel 0.0.31"},{"location":"advanced/benchmarks/#test-data","title":"Test Data","text":"<ul> <li>Users: 1000</li> <li>Posts per user: 20</li> </ul>"},{"location":"advanced/benchmarks/#methodology","title":"Methodology","text":"<p>Benchmarks are available in a separate repository: oxyde-benchmarks</p> <p>Configuration:</p> <ul> <li>100 iterations per test</li> <li>10 warmup iterations</li> <li>Connection pool warmed up before measurements</li> <li>Each ORM tested with recommended async drivers</li> </ul>"},{"location":"advanced/benchmarks/#next-steps","title":"Next Steps","text":"<ul> <li>Performance Tips \u2014 How to optimize your queries</li> <li>Internals \u2014 Rust core architecture</li> </ul>"},{"location":"advanced/internals/","title":"Internals (Rust Core)","text":"<p>This section documents Oxyde's Rust architecture for advanced users and contributors.</p>"},{"location":"advanced/internals/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Python Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502 Model  \u2502  \u2502   Query     \u2502  \u2502    db.*     \u2502              \u2502\n\u2502  \u2502  (Pydantic) \u2502  \u2502  (Builder)  \u2502  \u2502 (Async API) \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502         \u2502                \u2502                \u2502                      \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502\n\u2502                          \u2502                                       \u2502\n\u2502                    MessagePack (~2KB)                            \u2502\n\u2502                          \u2502                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Rust Core                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502 oxyde-codec \u2502  \u2502 oxyde-query \u2502  \u2502oxyde-driver \u2502              \u2502\n\u2502  \u2502  (IR Parse) \u2502  \u2502 (SQL Gen)   \u2502  \u2502(Connection) \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502         \u2502                \u2502                \u2502                      \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502\n\u2502                          \u2502                                       \u2502\n\u2502                       sqlx                                       \u2502\n\u2502                          \u2502                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502   Database              \u2502\n              \u2502  PostgreSQL/SQLite/MySQL\u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/internals/#rust-crates","title":"Rust Crates","text":""},{"location":"advanced/internals/#oxyde-codec","title":"oxyde-codec","text":"<p>Purpose: Define and validate the IR (Intermediate Representation) protocol.</p> <p>Location: <code>crates/oxyde-codec/src/lib.rs</code></p> <p>Key types:</p> <pre><code>pub struct QueryIR {\n    pub operation: Operation,\n    pub table: String,\n    pub columns: Option&lt;Vec&lt;String&gt;&gt;,\n    pub filter_tree: Option&lt;FilterNode&gt;,\n    pub limit: Option&lt;u32&gt;,\n    pub offset: Option&lt;u32&gt;,\n    pub order_by: Option&lt;Vec&lt;(String, String)&gt;&gt;,\n    // ... more fields\n}\n\npub enum Operation {\n    Select,\n    Insert,\n    Update,\n    Delete,\n}\n\npub enum FilterNode {\n    Condition {\n        field: String,\n        op: String,\n        value: Value,\n    },\n    And(Vec&lt;FilterNode&gt;),\n    Or(Vec&lt;FilterNode&gt;),\n    Not(Box&lt;FilterNode&gt;),\n}\n</code></pre>"},{"location":"advanced/internals/#oxyde-query","title":"oxyde-query","text":"<p>Purpose: Generate SQL from IR using sea-query.</p> <p>Location: <code>crates/oxyde-query/src/lib.rs</code></p> <p>Key functions:</p> <pre><code>pub fn build_sql(ir: &amp;QueryIR, dialect: Dialect) -&gt; Result&lt;(String, Vec&lt;Value&gt;)&gt; {\n    match ir.operation {\n        Operation::Select =&gt; build_select(ir, dialect),\n        Operation::Insert =&gt; build_insert(ir, dialect),\n        Operation::Update =&gt; build_update(ir, dialect),\n        Operation::Delete =&gt; build_delete(ir, dialect),\n    }\n}\n\npub enum Dialect {\n    Postgres,\n    Sqlite,\n    Mysql,\n}\n</code></pre>"},{"location":"advanced/internals/#oxyde-driver","title":"oxyde-driver","text":"<p>Purpose: Connection pooling, query execution, transaction management.</p> <p>Location: <code>crates/oxyde-driver/src/lib.rs</code></p> <p>Key components:</p> <pre><code>// Connection pool registry (global)\nstatic POOL_REGISTRY: OnceCell&lt;ConnectionRegistry&gt; = OnceCell::const_new();\n\n// Pool handle for each connection\npub struct PoolHandle {\n    pub pool: DbPool,\n    pub backend: DatabaseBackend,\n}\n\npub enum DbPool {\n    Postgres(PgPool),\n    MySql(MySqlPool),\n    Sqlite(SqlitePool),\n}\n\n// Transaction management\npub struct TransactionInner {\n    pub conn: Option&lt;DbConn&gt;,\n    pub state: TransactionState,\n    pub created_at: Instant,\n}\n</code></pre>"},{"location":"advanced/internals/#oxyde-migrate","title":"oxyde-migrate","text":"<p>Purpose: Schema diffing and migration generation.</p> <p>Location: <code>crates/oxyde-migrate/src/lib.rs</code></p> <p>Key functions:</p> <pre><code>pub fn compute_diff(old_schema: &amp;Schema, new_schema: &amp;Schema) -&gt; Vec&lt;Operation&gt; {\n    // Compare tables, columns, indexes\n    // Generate add/drop/alter operations\n}\n\npub fn generate_migration(operations: &amp;[Operation], dialect: Dialect) -&gt; String {\n    // Generate SQL migration script\n}\n</code></pre>"},{"location":"advanced/internals/#oxyde-core-py","title":"oxyde-core-py","text":"<p>Purpose: PyO3 bindings exposing Rust functions to Python.</p> <p>Location: <code>crates/oxyde-core-py/src/lib.rs</code></p> <p>Exposed functions:</p> <pre><code>#[pyfunction]\nfn init_pool(py: Python, name: String, url: String, settings: Option&lt;HashMap&lt;String, Value&gt;&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {\n    pyo3_asyncio::tokio::future_into_py(py, async move {\n        // Initialize pool in registry\n    })\n}\n\n#[pyfunction]\nfn execute(py: Python, pool_name: String, ir_bytes: &amp;[u8]) -&gt; PyResult&lt;&amp;PyAny&gt; {\n    pyo3_asyncio::tokio::future_into_py(py, async move {\n        // 1. Deserialize IR from MessagePack\n        // 2. Build SQL\n        // 3. Execute via sqlx\n        // 4. Serialize results to MessagePack\n    })\n}\n\n#[pyfunction]\nfn begin_transaction(py: Python, pool_name: String) -&gt; PyResult&lt;&amp;PyAny&gt; { ... }\n\n#[pyfunction]\nfn commit_transaction(py: Python, tx_id: u64) -&gt; PyResult&lt;&amp;PyAny&gt; { ... }\n\n#[pyfunction]\nfn rollback_transaction(py: Python, tx_id: u64) -&gt; PyResult&lt;&amp;PyAny&gt; { ... }\n</code></pre>"},{"location":"advanced/internals/#data-flow","title":"Data Flow","text":""},{"location":"advanced/internals/#query-execution","title":"Query Execution","text":"<pre><code>Python                          Rust\n\u2500\u2500\u2500\u2500\u2500\u2500                          \u2500\u2500\u2500\u2500\nUser.objects.filter(age=18)\n        \u2502\n        \u25bc\nQuery._build_filter_tree()\n        \u2502\n        \u25bc\nquery.to_ir() \u2192 dict\n        \u2502\n        \u25bc\nmsgpack.packb(ir) \u2192 bytes (~2KB)\n        \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 oxyde-codec: deserialize\n        \u2502                                  \u2502\n        \u2502                                  \u25bc\n        \u2502                          oxyde-query: build_sql()\n        \u2502                                  \u2502\n        \u2502                                  \u25bc\n        \u2502                          oxyde-driver: execute()\n        \u2502                                  \u2502\n        \u2502                                  \u25bc\n        \u2502                          sqlx \u2192 Database\n        \u2502                                  \u2502\n        \u2502                                  \u25bc\n        \u2502                          oxyde-driver: serialize results\n        \u2502                                  \u2502\n        \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\nmsgpack.unpackb(result_bytes)\n        \u2502\n        \u25bc\nPydantic: Model.model_validate()\n        \u2502\n        \u25bc\nUser instances\n</code></pre>"},{"location":"advanced/internals/#ir-format-example","title":"IR Format Example","text":"<pre><code># Python query\nUser.objects.filter(age__gte=18, status=\"active\").order_by(\"-created_at\").limit(10)\n\n# Generated IR (Python dict \u2192 MessagePack)\n{\n    \"type\": \"select\",\n    \"table\": \"users\",\n    \"model\": \"myapp.models.User\",\n    \"columns\": [\"id\", \"name\", \"email\", \"age\", \"status\", \"created_at\"],\n    \"filter_tree\": {\n        \"type\": \"and\",\n        \"children\": [\n            {\"type\": \"condition\", \"field\": \"age\", \"op\": \"gte\", \"value\": 18},\n            {\"type\": \"condition\", \"field\": \"status\", \"op\": \"eq\", \"value\": \"active\"}\n        ]\n    },\n    \"order_by\": [[\"created_at\", \"desc\"]],\n    \"limit\": 10\n}\n</code></pre>"},{"location":"advanced/internals/#gil-release","title":"GIL Release","text":"<p>Rust async operations release Python's GIL:</p> <pre><code>#[pyfunction]\nfn execute(py: Python, pool_name: String, ir_bytes: &amp;[u8]) -&gt; PyResult&lt;&amp;PyAny&gt; {\n    // Deserialize outside async (holds GIL)\n    let ir: QueryIR = rmp_serde::from_slice(ir_bytes)?;\n\n    // Release GIL for async I/O\n    pyo3_asyncio::tokio::future_into_py(py, async move {\n        // This runs without GIL\n        let result = execute_query(&amp;ir).await?;\n        Ok(result)\n    })\n}\n</code></pre>"},{"location":"advanced/internals/#connection-registry","title":"Connection Registry","text":"<p>Global registry for connection pools:</p> <pre><code>pub struct ConnectionRegistry {\n    pools: RwLock&lt;HashMap&lt;String, PoolHandle&gt;&gt;,\n}\n\nimpl ConnectionRegistry {\n    pub async fn insert(&amp;self, name: String, handle: PoolHandle) -&gt; Result&lt;()&gt; {\n        let mut guard = self.pools.write().await;\n        if guard.contains_key(&amp;name) {\n            return Err(DriverError::PoolAlreadyExists(name));\n        }\n        guard.insert(name, handle);\n        Ok(())\n    }\n\n    pub async fn get(&amp;self, name: &amp;str) -&gt; Result&lt;PoolHandle&gt; {\n        let guard = self.pools.read().await;\n        guard.get(name)\n            .cloned()\n            .ok_or_else(|| DriverError::PoolNotFound(name.to_string()))\n    }\n}\n</code></pre>"},{"location":"advanced/internals/#transaction-management","title":"Transaction Management","text":"<p>Transactions are stored in a separate registry:</p> <pre><code>pub struct TransactionRegistry {\n    transactions: RwLock&lt;HashMap&lt;u64, TransactionInner&gt;&gt;,\n    next_id: AtomicU64,\n}\n\nimpl TransactionRegistry {\n    pub async fn begin(&amp;self, pool_name: &amp;str) -&gt; Result&lt;u64&gt; {\n        let tx_id = self.next_id.fetch_add(1, Ordering::SeqCst);\n        let pool = POOL_REGISTRY.get()?.get(pool_name).await?;\n        let conn = begin_on_pool(&amp;pool.pool, pool.backend).await?;\n\n        let inner = TransactionInner {\n            conn: Some(conn),\n            state: TransactionState::Active,\n            created_at: Instant::now(),\n        };\n\n        self.transactions.write().await.insert(tx_id, inner);\n        Ok(tx_id)\n    }\n}\n</code></pre>"},{"location":"advanced/internals/#building-from-source","title":"Building from Source","text":"<pre><code># Build all crates\ncargo build --release\n\n# Build Python extension\ncd crates/oxyde-core-py\nmaturin develop --release\n\n# Run Rust tests\ncargo test --workspace\n\n# Run with logging\nRUST_LOG=debug cargo test\n</code></pre>"},{"location":"advanced/internals/#debugging","title":"Debugging","text":""},{"location":"advanced/internals/#enable-rust-logging","title":"Enable Rust Logging","text":"<pre><code>export RUST_LOG=info  # or debug, trace\npython your_script.py\n</code></pre>"},{"location":"advanced/internals/#inspect-ir","title":"Inspect IR","text":"<pre><code>query = User.objects.filter(age__gte=18)\nir = query.to_ir()\nimport json\nprint(json.dumps(ir, indent=2))\n</code></pre>"},{"location":"advanced/internals/#check-sql","title":"Check SQL","text":"<pre><code>sql, params = query.sql(dialect=\"postgres\")\nprint(sql)\nprint(params)\n</code></pre>"},{"location":"advanced/internals/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/internals/#messagepack-overhead","title":"MessagePack Overhead","text":"<ul> <li>Typical IR size: 1-3KB</li> <li>Serialization: ~50\u03bcs</li> <li>Deserialization: ~30\u03bcs</li> <li>Negligible compared to network I/O</li> </ul>"},{"location":"advanced/internals/#sql-generation","title":"SQL Generation","text":"<ul> <li>sea-query is highly optimized</li> <li>SQL building: ~10-50\u03bcs per query</li> <li>Cached prepared statements in sqlx</li> </ul>"},{"location":"advanced/internals/#connection-pool","title":"Connection Pool","text":"<ul> <li>Pool acquisition: ~1\u03bcs (cached)</li> <li>New connection: ~1-10ms (database dependent)</li> <li>Keep <code>min_connections &gt; 0</code> for production</li> </ul>"},{"location":"advanced/internals/#contributing","title":"Contributing","text":""},{"location":"advanced/internals/#adding-a-new-operation","title":"Adding a New Operation","text":"<ol> <li> <p>Define IR in <code>oxyde-codec</code>:    <pre><code>pub struct NewOperationIR { ... }\n</code></pre></p> </li> <li> <p>Add SQL generation in <code>oxyde-query</code>:    <pre><code>fn build_new_operation(ir: &amp;NewOperationIR, dialect: Dialect) -&gt; Result&lt;...&gt;\n</code></pre></p> </li> <li> <p>Expose in <code>oxyde-core-py</code>:    <pre><code>#[pyfunction]\nfn new_operation(...) -&gt; PyResult&lt;...&gt;\n</code></pre></p> </li> <li> <p>Add Python wrapper in <code>python/oxyde/queries/</code></p> </li> <li> <p>Rebuild:    <pre><code>cd crates/oxyde-core-py &amp;&amp; maturin develop --release\n</code></pre></p> </li> </ol>"},{"location":"advanced/internals/#next-steps","title":"Next Steps","text":"<ul> <li>Performance \u2014 Optimization techniques</li> <li>Raw Queries \u2014 Direct SQL execution</li> <li>Connections \u2014 Connection configuration</li> </ul>"},{"location":"advanced/performance/","title":"Performance","text":"<p>Oxyde is designed for high performance through its Rust core. This guide covers optimization techniques.</p>"},{"location":"advanced/performance/#architecture-overview","title":"Architecture Overview","text":"<pre><code>Python Layer                Rust Core                Database\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Pydantic    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 SQL Gen     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 PostgreSQL\u2502\n\u2502 Models      \u2502 msgpack  \u2502 Connection  \u2502    sqlx   \u2502 SQLite    \u2502\n\u2502 QuerySet    \u2502  ~2KB    \u2502 Pool        \u2502           \u2502 MySQL     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key performance characteristics:</p> <ul> <li>MessagePack protocol: ~2KB binary payloads</li> <li>Rust SQL generation: sea-query for fast SQL building</li> <li>Native async: sqlx releases Python GIL during I/O</li> <li>Connection pooling: Efficient connection reuse</li> </ul>"},{"location":"advanced/performance/#query-optimization","title":"Query Optimization","text":""},{"location":"advanced/performance/#select-only-needed-fields","title":"Select Only Needed Fields","text":"<pre><code># BAD: Loads all columns\nusers = await User.objects.all()\n\n# GOOD: Load only what you need\nusers = await User.objects.values(\"id\", \"name\").all()\n</code></pre>"},{"location":"advanced/performance/#use-limits","title":"Use Limits","text":"<pre><code># BAD: Loads all records\nusers = await User.objects.filter(status=\"active\").all()\n\n# GOOD: Paginate\nusers = await User.objects.filter(status=\"active\").limit(100).all()\n</code></pre>"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":"<pre><code># BAD: N individual inserts\nfor item in items:\n    await Item.objects.create(**item)\n\n# GOOD: Bulk insert\nawait Item.objects.bulk_create([Item(**item) for item in items])\n</code></pre>"},{"location":"advanced/performance/#use-f-expressions","title":"Use F Expressions","text":"<pre><code># BAD: Read-modify-write (race condition + 2 queries)\npost = await Post.objects.get(id=1)\npost.views += 1\nawait post.save()\n\n# GOOD: Atomic update (1 query)\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\n</code></pre>"},{"location":"advanced/performance/#avoid-querying-in-loops","title":"Avoid Querying in Loops","text":"<pre><code># BAD: Multiple queries\nposts = await Post.objects.all()\nfor post in posts:\n    author = await Author.objects.get(id=post.author_id)  # N queries!\n\n# GOOD: Eager loading with join (1 query)\nposts = await Post.objects.join(\"author\").all()\nfor post in posts:\n    print(post.author.name)  # Data already loaded\n</code></pre>"},{"location":"advanced/performance/#connection-pool-tuning","title":"Connection Pool Tuning","text":""},{"location":"advanced/performance/#pool-size","title":"Pool Size","text":"<pre><code>from oxyde import PoolSettings\n\n# Web API: many concurrent connections\nsettings = PoolSettings(\n    max_connections=50,\n    min_connections=10,\n)\n\n# Background worker: fewer long-lived connections\nsettings = PoolSettings(\n    max_connections=10,\n    min_connections=2,\n)\n\n# SQLite: limited concurrency\nsettings = PoolSettings(\n    max_connections=5,  # SQLite handles this well with WAL\n)\n</code></pre>"},{"location":"advanced/performance/#connection-lifecycle","title":"Connection Lifecycle","text":"<pre><code>settings = PoolSettings(\n    acquire_timeout=30,     # Don't wait forever\n    idle_timeout=300,       # Close idle after 5 min\n    max_lifetime=3600,      # Refresh connections hourly\n    test_before_acquire=True,  # Ping before use\n)\n</code></pre>"},{"location":"advanced/performance/#sqlite-optimization","title":"SQLite Optimization","text":"<p>Oxyde applies optimized defaults for SQLite:</p> <pre><code># Default settings (applied automatically)\nPoolSettings(\n    sqlite_journal_mode=\"WAL\",    # 10-20x faster writes\n    sqlite_synchronous=\"NORMAL\",  # Balance safety/speed\n    sqlite_cache_size=10000,      # ~10MB cache\n    sqlite_busy_timeout=5000,     # 5 sec lock timeout\n)\n</code></pre>"},{"location":"advanced/performance/#wal-mode-benefits","title":"WAL Mode Benefits","text":"<ul> <li>Concurrent reads: Multiple readers don't block</li> <li>Faster writes: Sequential log instead of random I/O</li> <li>Crash recovery: Better durability</li> </ul>"},{"location":"advanced/performance/#when-to-override","title":"When to Override","text":"<pre><code># Maximum safety (slower)\nPoolSettings(\n    sqlite_journal_mode=\"DELETE\",\n    sqlite_synchronous=\"FULL\",\n)\n\n# Maximum speed (less safe for power failure)\nPoolSettings(\n    sqlite_synchronous=\"OFF\",\n    sqlite_cache_size=50000,  # 50MB cache\n)\n</code></pre>"},{"location":"advanced/performance/#indexing-strategies","title":"Indexing Strategies","text":""},{"location":"advanced/performance/#single-column-indexes","title":"Single-Column Indexes","text":"<pre><code>class User(Model):\n    email: str = Field(db_index=True)  # For equality lookups\n    created_at: datetime = Field(db_index=True)  # For range queries\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"advanced/performance/#composite-indexes","title":"Composite Indexes","text":"<pre><code>from oxyde import Index\n\nclass Event(Model):\n    user_id: int\n    created_at: datetime\n\n    class Meta:\n        is_table = True\n        indexes = [\n            # Order matters: (user_id, date) supports:\n            # - WHERE user_id = ?\n            # - WHERE user_id = ? AND date &gt; ?\n            # But NOT: WHERE date &gt; ? (without user_id)\n            Index((\"user_id\", \"created_at\")),\n        ]\n</code></pre>"},{"location":"advanced/performance/#partial-indexes","title":"Partial Indexes","text":"<pre><code>class User(Model):\n    email: str\n    deleted_at: datetime | None = None\n\n    class Meta:\n        is_table = True\n        indexes = [\n            # Only index active users\n            Index((\"email\",), unique=True, where=\"deleted_at IS NULL\"),\n        ]\n</code></pre>"},{"location":"advanced/performance/#explain-queries","title":"Explain Queries","text":"<p>Analyze query performance:</p> <pre><code># Get query plan\nplan = await User.objects.filter(age__gte=18).explain()\nprint(plan)\n\n# With execution times\nplan = await User.objects.filter(age__gte=18).explain(analyze=True)\nprint(plan)\n</code></pre> <p>PostgreSQL output example:</p> <pre><code>Seq Scan on users  (cost=0.00..1.50 rows=33 width=40)\n  Filter: (age &gt;= 18)\n</code></pre> <p>Add index if you see \"Seq Scan\" on large tables.</p>"},{"location":"advanced/performance/#async-concurrency","title":"Async Concurrency","text":""},{"location":"advanced/performance/#concurrent-queries","title":"Concurrent Queries","text":"<pre><code>import asyncio\n\n# BAD: Sequential\nuser = await User.objects.get(id=1)\nposts = await Post.objects.filter(author_id=1).all()\ncomments = await Comment.objects.filter(user_id=1).all()\n\n# GOOD: Concurrent\nuser, posts, comments = await asyncio.gather(\n    User.objects.get(id=1),\n    Post.objects.filter(author_id=1).all(),\n    Comment.objects.filter(user_id=1).all(),\n)\n</code></pre>"},{"location":"advanced/performance/#task-groups-python-311","title":"Task Groups (Python 3.11+)","text":"<pre><code>async with asyncio.TaskGroup() as tg:\n    user_task = tg.create_task(User.objects.get(id=1))\n    posts_task = tg.create_task(Post.objects.filter(author_id=1).all())\n\nuser = user_task.result()\nposts = posts_task.result()\n</code></pre>"},{"location":"advanced/performance/#benchmarking-tips","title":"Benchmarking Tips","text":""},{"location":"advanced/performance/#warm-up","title":"Warm Up","text":"<pre><code># Warm up connection pool\nawait User.objects.first()\n\n# Then benchmark\nimport time\nstart = time.perf_counter()\nfor _ in range(1000):\n    await User.objects.filter(status=\"active\").all()\nelapsed = time.perf_counter() - start\nprint(f\"1000 queries in {elapsed:.2f}s ({1000/elapsed:.0f} qps)\")\n</code></pre>"},{"location":"advanced/performance/#realistic-conditions","title":"Realistic Conditions","text":"<ul> <li>Use production-like data volumes</li> <li>Test with concurrent connections</li> <li>Include network latency</li> </ul>"},{"location":"advanced/performance/#common-bottlenecks","title":"Common Bottlenecks","text":"Symptom Cause Solution Slow queries Missing index Add index, use explain() High latency Queries in loops Use join() or prefetch() Pool exhaustion Too few connections Increase max_connections Lock contention Long transactions Shorten transactions Memory spikes Large result sets Use limit(), pagination"},{"location":"advanced/performance/#performance-checklist","title":"Performance Checklist","text":"<ul> <li>[ ] Use <code>values()</code> to select only needed columns</li> <li>[ ] Add indexes for filtered columns</li> <li>[ ] Use <code>join()</code> to load related objects</li> <li>[ ] Use <code>bulk_create()</code> for batch inserts</li> <li>[ ] Use <code>F()</code> expressions for atomic updates</li> <li>[ ] Configure appropriate pool size</li> <li>[ ] Use SQLite WAL mode (default)</li> <li>[ ] Profile slow queries with <code>explain()</code></li> <li>[ ] Use <code>asyncio.gather()</code> for concurrent queries</li> </ul>"},{"location":"advanced/performance/#next-steps","title":"Next Steps","text":"<ul> <li>Internals \u2014 Rust core architecture</li> <li>Connections \u2014 Connection configuration</li> </ul>"},{"location":"advanced/raw-queries/","title":"Raw Queries","text":"<p>For complex queries not expressible through the ORM, Oxyde supports raw SQL.</p> <p>SQL Injection</p> <p>Always use parameterized queries. Never interpolate user input directly into SQL strings.</p>"},{"location":"advanced/raw-queries/#execute_raw","title":"execute_raw()","text":"<p>The primary way to execute raw SQL:</p> <pre><code>from oxyde import execute_raw\n\n# Simple SELECT\nusers = await execute_raw(\"SELECT * FROM users WHERE age &gt; $1\", [18])\n\n# Returns list of dicts\nfor user in users:\n    print(user[\"name\"], user[\"email\"])\n</code></pre>"},{"location":"advanced/raw-queries/#connection-resolution","title":"Connection Resolution","text":"<p><code>execute_raw()</code> uses the same connection resolution as <code>Model.objects</code>:</p> <ol> <li>Active transaction (if inside <code>atomic()</code>)</li> <li>Named connection (<code>using=\"alias\"</code>)</li> <li>Default connection</li> </ol> <pre><code># Uses default connection\nresults = await execute_raw(\"SELECT * FROM users\")\n\n# Uses specific connection\nresults = await execute_raw(\"SELECT * FROM metrics\", using=\"analytics\")\n\n# Inside transaction - automatically uses same transaction\nasync with transaction.atomic():\n    await User.objects.create(name=\"Alice\")\n    await execute_raw(\n        \"INSERT INTO audit_log (user_id, action) VALUES ($1, $2)\",\n        [1, \"created\"]\n    )\n    # Both operations in same transaction\n</code></pre>"},{"location":"advanced/raw-queries/#rawsql-in-annotations","title":"RawSQL in Annotations","text":"<p>Use raw SQL expressions in annotations:</p> <pre><code>from oxyde import RawSQL\n\n# Custom SQL expression\nresults = await User.objects.annotate(\n    name_length=RawSQL(\"LENGTH(name)\")\n).all()\n\n# Database-specific functions\nresults = await User.objects.annotate(\n    created_date=RawSQL(\"DATE(created_at)\")\n).all()\n</code></pre>"},{"location":"advanced/raw-queries/#querysql","title":"Query.sql()","text":"<p>Get the generated SQL without executing:</p> <pre><code>query = User.objects.filter(age__gte=18).order_by(\"-created_at\").limit(10)\n\n# Get SQL and parameters\nsql, params = query.sql()\nprint(f\"SQL: {sql}\")\nprint(f\"Params: {params}\")\n\n# With specific dialect\nsql, params = query.sql(dialect=\"postgres\")\nsql, params = query.sql(dialect=\"sqlite\")\nsql, params = query.sql(dialect=\"mysql\")\n</code></pre>"},{"location":"advanced/raw-queries/#common-use-cases","title":"Common Use Cases","text":""},{"location":"advanced/raw-queries/#window-functions","title":"Window Functions","text":"<pre><code># Window functions (not supported in ORM)\nresults = await execute_raw(\"\"\"\n    SELECT\n        id,\n        name,\n        salary,\n        RANK() OVER (ORDER BY salary DESC) as rank\n    FROM employees\n    WHERE department_id = $1\n\"\"\", [department_id])\n</code></pre>"},{"location":"advanced/raw-queries/#database-specific-features","title":"Database-Specific Features","text":"<pre><code># PostgreSQL JSONB operators\nresults = await execute_raw(\"\"\"\n    SELECT * FROM products\n    WHERE metadata @&gt; '{\"featured\": true}'::jsonb\n\"\"\")\n\n# PostgreSQL full-text search\nresults = await execute_raw(\"\"\"\n    SELECT * FROM articles\n    WHERE to_tsvector('english', content) @@ plainto_tsquery('english', $1)\n\"\"\", [search_term])\n\n# SQLite JSON functions\nresults = await execute_raw(\"\"\"\n    SELECT * FROM products\n    WHERE json_extract(metadata, '$.featured') = 1\n\"\"\")\n</code></pre>"},{"location":"advanced/raw-queries/#complex-joins","title":"Complex Joins","text":"<pre><code># Self-join with aliases\nresults = await execute_raw(\"\"\"\n    SELECT\n        e.name as employee,\n        m.name as manager\n    FROM employees e\n    LEFT JOIN employees m ON e.manager_id = m.id\n    WHERE e.department_id = $1\n\"\"\", [department_id])\n</code></pre>"},{"location":"advanced/raw-queries/#recursive-ctes","title":"Recursive CTEs","text":"<pre><code># Recursive category tree\nresults = await execute_raw(\"\"\"\n    WITH RECURSIVE category_tree AS (\n        SELECT id, name, parent_id, 0 as depth\n        FROM categories\n        WHERE parent_id IS NULL\n\n        UNION ALL\n\n        SELECT c.id, c.name, c.parent_id, ct.depth + 1\n        FROM categories c\n        JOIN category_tree ct ON c.parent_id = ct.id\n    )\n    SELECT * FROM category_tree\n    ORDER BY depth, name\n\"\"\")\n</code></pre>"},{"location":"advanced/raw-queries/#bulk-operations","title":"Bulk Operations","text":"<pre><code># UPSERT (PostgreSQL)\nsql = \"\"\"\n    INSERT INTO products (sku, name, price)\n    VALUES ($1, $2, $3)\n    ON CONFLICT (sku)\n    DO UPDATE SET\n        name = EXCLUDED.name,\n        price = EXCLUDED.price\n\"\"\"\n\nfor product in products:\n    await execute_raw(sql, [product.sku, product.name, product.price])\n</code></pre>"},{"location":"advanced/raw-queries/#parameter-binding","title":"Parameter Binding","text":""},{"location":"advanced/raw-queries/#postgresql","title":"PostgreSQL","text":"<p>Uses <code>$1</code>, <code>$2</code>, etc.:</p> <pre><code>results = await execute_raw(\n    \"SELECT * FROM users WHERE age &gt;= $1 AND status = $2\",\n    [18, \"active\"]\n)\n</code></pre>"},{"location":"advanced/raw-queries/#sqlite","title":"SQLite","text":"<p>Uses <code>?</code> placeholders:</p> <pre><code>results = await execute_raw(\n    \"SELECT * FROM users WHERE age &gt;= ? AND status = ?\",\n    [18, \"active\"]\n)\n</code></pre>"},{"location":"advanced/raw-queries/#mysql","title":"MySQL","text":"<p>Uses <code>?</code> placeholders:</p> <pre><code>results = await execute_raw(\n    \"SELECT * FROM users WHERE age &gt;= ? AND status = ?\",\n    [18, \"active\"]\n)\n</code></pre>"},{"location":"advanced/raw-queries/#mixing-raw-and-orm","title":"Mixing Raw and ORM","text":""},{"location":"advanced/raw-queries/#filter-with-raw-sql","title":"Filter with Raw SQL","text":"<pre><code># Get IDs from raw query\nresults = await execute_raw(\"\"\"\n    SELECT user_id FROM user_scores\n    WHERE score &gt; (SELECT AVG(score) FROM user_scores)\n\"\"\")\nuser_ids = [r[\"user_id\"] for r in results]\n\n# Use in ORM query\nhigh_scorers = await User.objects.filter(id__in=user_ids).all()\n</code></pre>"},{"location":"advanced/raw-queries/#supplement-orm-queries","title":"Supplement ORM Queries","text":"<pre><code># ORM for basic query\nusers = await User.objects.filter(status=\"active\").all()\n\n# Raw SQL for complex aggregation\nuser_ids = [u.id for u in users]\nstats = await execute_raw(\"\"\"\n    SELECT user_id, COUNT(*) as post_count\n    FROM posts\n    WHERE user_id = ANY($1)\n    GROUP BY user_id\n\"\"\", [user_ids])\n</code></pre>"},{"location":"advanced/raw-queries/#transaction-support","title":"Transaction Support","text":"<p>Raw queries automatically participate in transactions:</p> <pre><code>from oxyde import atomic, execute_raw\n\nasync with atomic():\n    # ORM operation\n    user = await User.objects.create(name=\"Alice\")\n\n    # Raw SQL in same transaction\n    await execute_raw(\n        \"INSERT INTO audit_log (user_id, action) VALUES ($1, $2)\",\n        [user.id, \"created\"]\n    )\n    # Both commit together or rollback together\n</code></pre>"},{"location":"advanced/raw-queries/#explain","title":"explain()","text":"<p>Analyze query performance:</p> <pre><code># Using ORM explain\nplan = await User.objects.filter(age__gte=18).explain(analyze=True)\n\n# Raw SQL explain\nresults = await execute_raw(\"EXPLAIN ANALYZE SELECT * FROM users WHERE age &gt;= 18\")\n</code></pre>"},{"location":"advanced/raw-queries/#best-practices","title":"Best Practices","text":""},{"location":"advanced/raw-queries/#1-prefer-orm-when-possible","title":"1. Prefer ORM When Possible","text":"<pre><code># Use ORM for standard operations\nusers = await User.objects.filter(status=\"active\").all()\n\n# Use raw SQL only for unsupported features\nresults = await execute_raw(\n    \"SELECT * FROM users WHERE metadata @&gt; $1::jsonb\",\n    ['{\"vip\": true}']\n)\n</code></pre>"},{"location":"advanced/raw-queries/#2-parameterize-everything","title":"2. Parameterize Everything","text":"<pre><code># GOOD\nawait execute_raw(\"SELECT * FROM users WHERE email = $1\", [user_email])\n\n# BAD - SQL injection risk!\nawait execute_raw(f\"SELECT * FROM users WHERE email = '{user_email}'\")\n</code></pre>"},{"location":"advanced/raw-queries/#3-document-complex-queries","title":"3. Document Complex Queries","text":"<pre><code>async def get_user_activity_report(user_id: int):\n    \"\"\"\n    Get user activity report with window functions.\n\n    Returns posts with running total of views and rank within user's posts.\n    \"\"\"\n    return await execute_raw(\"\"\"\n        SELECT\n            id,\n            title,\n            views,\n            SUM(views) OVER (ORDER BY created_at) as running_total,\n            RANK() OVER (ORDER BY views DESC) as view_rank\n        FROM posts\n        WHERE author_id = $1\n        ORDER BY created_at DESC\n    \"\"\", [user_id])\n</code></pre>"},{"location":"advanced/raw-queries/#4-test-across-databases","title":"4. Test Across Databases","text":"<pre><code>def get_date_trunc_sql(field: str, unit: str, dialect: str) -&gt; str:\n    \"\"\"Generate date truncation SQL for different dialects.\"\"\"\n    if dialect == \"postgres\":\n        return f\"DATE_TRUNC('{unit}', {field})\"\n    elif dialect == \"sqlite\":\n        if unit == \"day\":\n            return f\"DATE({field})\"\n        elif unit == \"month\":\n            return f\"DATE({field}, 'start of month')\"\n    elif dialect == \"mysql\":\n        return f\"DATE_FORMAT({field}, '%Y-%m-01')\"\n</code></pre>"},{"location":"advanced/raw-queries/#limitations","title":"Limitations","text":""},{"location":"advanced/raw-queries/#no-automatic-type-conversion","title":"No Automatic Type Conversion","text":"<p>Raw queries return raw values:</p> <pre><code># ORM converts types\nuser = await User.objects.get(id=1)\nprint(type(user.created_at))  # datetime\n\n# Raw may return strings (depends on driver and column type)\nresults = await execute_raw(\"SELECT created_at FROM users WHERE id = $1\", [1])\nprint(type(results[0][\"created_at\"]))  # str or datetime\n</code></pre>"},{"location":"advanced/raw-queries/#no-model-hydration","title":"No Model Hydration","text":"<p>Raw queries return dictionaries, not model instances:</p> <pre><code># ORM returns models\nusers = await User.objects.all()\nprint(type(users[0]))  # User\n\n# Raw returns dicts\nresults = await execute_raw(\"SELECT * FROM users\")\nprint(type(results[0]))  # dict\n</code></pre> <p>To hydrate manually:</p> <pre><code>rows = await execute_raw(\"SELECT * FROM users WHERE ...\")\nusers = [User.model_validate(row) for row in rows]\n</code></pre>"},{"location":"advanced/raw-queries/#api-reference","title":"API Reference","text":"<pre><code>async def execute_raw(\n    sql: str,\n    params: list[Any] | None = None,\n    *,\n    using: str | None = None,\n    client: SupportsExecute | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Execute raw SQL query.\n\n    Args:\n        sql: SQL with placeholders ($1/$2 for Postgres, ? for SQLite/MySQL)\n        params: Query parameters (use these to prevent SQL injection!)\n        using: Connection alias (default: \"default\")\n        client: Explicit client (AsyncDatabase or AsyncTransaction)\n\n    Returns:\n        List of dicts for SELECT queries.\n        Empty list for INSERT/UPDATE/DELETE without RETURNING.\n\n    Raises:\n        RuntimeError: If no connection is available.\n        ManagerError: If both 'using' and 'client' are provided.\n    \"\"\"\n</code></pre>"},{"location":"advanced/raw-queries/#next-steps","title":"Next Steps","text":"<ul> <li>Internals \u2014 Rust core architecture</li> <li>Performance \u2014 Optimization techniques</li> <li>Queries \u2014 ORM query reference</li> </ul>"},{"location":"getting-started/fastapi-project/","title":"FastAPI Project","text":"<p>Complete example of using Oxyde with FastAPI.</p> <p>Full working example: github.com/mr-fatalyst/fastapi-oxyde-example</p>"},{"location":"getting-started/fastapi-project/#setup","title":"Setup","text":"<pre><code>pip install oxyde fastapi uvicorn\n</code></pre>"},{"location":"getting-started/fastapi-project/#project-structure","title":"Project Structure","text":"<pre><code>myapp/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 routes.py\n</code></pre>"},{"location":"getting-started/fastapi-project/#models","title":"Models","text":"<pre><code># models.py\nfrom oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n    is_active: bool = True\n\n    class Meta:\n        is_table = True\n        table_name = \"users\"\n\nclass Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    content: str\n    author: \"User\" | None = Field(default=None)\n\n    class Meta:\n        is_table = True\n        table_name = \"posts\"\n</code></pre>"},{"location":"getting-started/fastapi-project/#application","title":"Application","text":"<pre><code># main.py\nfrom fastapi import FastAPI\nfrom oxyde import db\n\nfrom routes import router\n\napp = FastAPI(\n    lifespan=db.lifespan(default=\"sqlite:///app.db\")\n)\napp.include_router(router)\n</code></pre> <p>Before first run, create tables with migrations:</p> <pre><code>oxyde makemigrations\noxyde migrate\n</code></pre>"},{"location":"getting-started/fastapi-project/#routes","title":"Routes","text":"<pre><code># routes.py\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\nfrom models import User, Post\n\nrouter = APIRouter()\n\n# --- Schemas ---\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\nclass PostCreate(BaseModel):\n    title: str\n    content: str\n    author_id: int\n\n# --- Users ---\n\n@router.get(\"/users\")\nasync def list_users():\n    return await User.objects.all()\n\n@router.get(\"/users/{id}\")\nasync def get_user(id: int):\n    user = await User.objects.get_or_none(id=id)\n    if not user:\n        raise HTTPException(404, \"User not found\")\n    return user\n\n@router.post(\"/users\", status_code=201)\nasync def create_user(data: UserCreate):\n    return await User.objects.create(**data.model_dump())\n\n@router.patch(\"/users/{id}\")\nasync def update_user(id: int, data: UserCreate):\n    user = await User.objects.get_or_none(id=id)\n    if not user:\n        raise HTTPException(404, \"User not found\")\n    user.name = data.name\n    user.email = data.email\n    await user.save()\n    return user\n\n@router.delete(\"/users/{id}\", status_code=204)\nasync def delete_user(id: int):\n    count = await User.objects.filter(id=id).delete()\n    if not count:\n        raise HTTPException(404, \"User not found\")\n\n# --- Posts ---\n\n@router.get(\"/posts\")\nasync def list_posts():\n    return await Post.objects.all()\n\n@router.get(\"/users/{user_id}/posts\")\nasync def list_user_posts(user_id: int):\n    return await Post.objects.filter(author_id=user_id).all()\n\n@router.post(\"/posts\", status_code=201)\nasync def create_post(data: PostCreate):\n    # Verify author exists\n    if not await User.objects.filter(id=data.author_id).exists():\n        raise HTTPException(400, \"Author not found\")\n    return await Post.objects.create(**data.model_dump())\n</code></pre>"},{"location":"getting-started/fastapi-project/#run","title":"Run","text":"<pre><code>uvicorn main:app --reload\n</code></pre> <p>API available at <code>http://localhost:8000/docs</code></p>"},{"location":"getting-started/fastapi-project/#with-transactions","title":"With Transactions","text":"<pre><code>from oxyde.db import transaction\n\n@router.post(\"/users/with-post\", status_code=201)\nasync def create_user_with_post(data: UserCreate, post_title: str):\n    async with transaction.atomic():\n        user = await User.objects.create(**data.model_dump())\n        post = await Post.objects.create(\n            title=post_title,\n            content=\"First post!\",\n            author_id=user.id\n        )\n    return {\"user\": user, \"post\": post}\n</code></pre>"},{"location":"getting-started/fastapi-project/#with-pagination","title":"With Pagination","text":"<pre><code>@router.get(\"/posts/paginated\")\nasync def list_posts_paginated(page: int = 1, per_page: int = 10):\n    offset = (page - 1) * per_page\n    posts = await Post.objects.order_by(\"-id\").offset(offset).limit(per_page).all()\n    total = await Post.objects.count()\n    return {\n        \"items\": posts,\n        \"total\": total,\n        \"page\": page,\n        \"pages\": (total + per_page - 1) // per_page\n    }\n</code></pre>"},{"location":"getting-started/fastapi-project/#next-steps","title":"Next Steps","text":"<ul> <li>Queries \u2014 Query API</li> <li>Filtering \u2014 Filter conditions</li> <li>Transactions \u2014 Atomic operations</li> </ul>"},{"location":"getting-started/first-project/","title":"First Project","text":"<p>Let's build a simple blog application to learn Oxyde's core features.</p>"},{"location":"getting-started/first-project/#project-structure","title":"Project Structure","text":"<pre><code>blog/\n\u251c\u2500\u2500 models.py          # Database models\n\u251c\u2500\u2500 oxyde_config.py    # Oxyde configuration\n\u251c\u2500\u2500 migrations/        # Migration files\n\u251c\u2500\u2500 main.py            # Application logic\n\u2514\u2500\u2500 blog.db            # SQLite database (auto-created)\n</code></pre>"},{"location":"getting-started/first-project/#step-1-initialize-project","title":"Step 1: Initialize Project","text":"<p>Create a new directory and initialize Oxyde:</p> <pre><code>mkdir blog &amp;&amp; cd blog\noxyde init\n</code></pre> <p>When prompted:</p> <ul> <li>Models module: <code>models</code></li> <li>Dialect: <code>sqlite</code></li> <li>Database URL: <code>sqlite:///blog.db</code></li> <li>Migrations directory: <code>migrations</code></li> </ul>"},{"location":"getting-started/first-project/#step-2-define-models","title":"Step 2: Define Models","text":"<p>Create <code>models.py</code>:</p> <pre><code>from datetime import datetime\nfrom oxyde import Model, Field\n\n\nclass Author(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n    bio: str | None = Field(default=None)\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n    class Meta:\n        is_table = True\n        table_name = \"authors\"\n\n\nclass Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    content: str\n    published: bool = Field(default=False)\n    views: int = Field(default=0)\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n    class Meta:\n        is_table = True\n        table_name = \"posts\"\n\n\nclass Tag(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str = Field(db_unique=True)\n\n    class Meta:\n        is_table = True\n        table_name = \"tags\"\n</code></pre> <p>Key concepts:</p> <ul> <li><code>table_name</code> overrides the default table name</li> <li><code>db_default=\"CURRENT_TIMESTAMP\"</code> sets a SQL default</li> <li><code>author: \"Author\"</code> creates a foreign key relationship</li> <li><code>db_on_delete=\"CASCADE\"</code> deletes posts when author is deleted</li> </ul>"},{"location":"getting-started/first-project/#step-3-create-and-apply-migrations","title":"Step 3: Create and Apply Migrations","text":"<p>Generate migrations from models:</p> <pre><code>oxyde makemigrations\n</code></pre> <p>Apply to create tables:</p> <pre><code>oxyde migrate\n</code></pre>"},{"location":"getting-started/first-project/#step-4-create-the-application","title":"Step 4: Create the Application","text":"<p>Create <code>main.py</code>:</p> <pre><code>import asyncio\nfrom oxyde import db, F, Q\nfrom models import Author, Post, Tag\n\n\nasync def main():\n    # Connect to database\n    await db.init(default=\"sqlite:///blog.db\")\n\n    try:\n        # Create sample data\n        await create_sample_data()\n\n        # Run queries\n        await demo_queries()\n\n        # Show statistics\n        await show_stats()\n    finally:\n        await db.close()\n\n\nasync def create_sample_data():\n    \"\"\"Create authors, posts, and tags.\"\"\"\n    print(\"Creating sample data...\")\n\n    # Create authors\n    alice = await Author.objects.create(\n        name=\"Alice Johnson\",\n        email=\"alice@example.com\",\n        bio=\"Python developer and tech writer\"\n    )\n\n    bob = await Author.objects.create(\n        name=\"Bob Smith\",\n        email=\"bob@example.com\",\n        bio=\"Backend engineer\"\n    )\n\n    # Create posts\n    await Post.objects.create(\n        title=\"Getting Started with Oxyde\",\n        content=\"Oxyde is a high-performance async ORM...\",\n        published=True,\n        author_id=alice.id\n    )\n\n    await Post.objects.create(\n        title=\"Advanced Query Patterns\",\n        content=\"In this post, we explore advanced queries...\",\n        published=True,\n        views=150,\n        author_id=alice.id\n    )\n\n    await Post.objects.create(\n        title=\"Draft: Performance Tips\",\n        content=\"Work in progress...\",\n        published=False,\n        author_id=bob.id\n    )\n\n    # Create tags\n    for name in [\"python\", \"orm\", \"async\", \"tutorial\"]:\n        await Tag.objects.create(name=name)\n\n    print(\"Sample data created!\\n\")\n\n\nasync def demo_queries():\n    \"\"\"Demonstrate various query patterns.\"\"\"\n    print(\"=== Query Examples ===\\n\")\n\n    # Basic filtering\n    published = await Post.objects.filter(published=True).all()\n    print(f\"Published posts: {len(published)}\")\n\n    # Multiple conditions with Q\n    popular = await Post.objects.filter(\n        Q(published=True) &amp; Q(views__gte=100)\n    ).all()\n    print(f\"Popular posts (100+ views): {len(popular)}\")\n\n    # Ordering and limiting\n    recent = await Post.objects.filter(\n        published=True\n    ).order_by(\"-created_at\").limit(5).all()\n    print(f\"Recent posts: {[p.title for p in recent]}\")\n\n    # Get single record\n    author = await Author.objects.get(email=\"alice@example.com\")\n    print(f\"Found author: {author.name}\")\n\n    # Update with F expression (atomic increment)\n    await Post.objects.filter(title__contains=\"Oxyde\").update(\n        views=F(\"views\") + 1\n    )\n    print(\"Incremented views for Oxyde posts\")\n\n    # Values (return dicts instead of models)\n    emails = await Author.objects.values(\"name\", \"email\").all()\n    print(f\"Author emails: {emails}\")\n\n    # Exists check\n    has_drafts = await Post.objects.filter(published=False).exists()\n    print(f\"Has draft posts: {has_drafts}\")\n\n    print()\n\n\nasync def show_stats():\n    \"\"\"Show aggregate statistics.\"\"\"\n    print(\"=== Statistics ===\\n\")\n\n    # Count\n    total_posts = await Post.objects.count()\n    print(f\"Total posts: {total_posts}\")\n\n    # Sum\n    total_views = await Post.objects.sum(\"views\")\n    print(f\"Total views: {total_views}\")\n\n    # Average\n    avg_views = await Post.objects.avg(\"views\")\n    print(f\"Average views: {avg_views:.1f}\")\n\n    # Count with filter\n    published_count = await Post.objects.filter(published=True).count()\n    print(f\"Published posts: {published_count}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/first-project/#step-5-run-the-application","title":"Step 5: Run the Application","text":"<pre><code>python main.py\n</code></pre> <p>Expected output:</p> <pre><code>Creating sample data...\nSample data created!\n\n=== Query Examples ===\n\nPublished posts: 2\nPopular posts (100+ views): 1\nRecent posts: ['Advanced Query Patterns', 'Getting Started with Oxyde']\nFound author: Alice Johnson\nIncremented views for Oxyde posts\nAuthor emails: [{'name': 'Alice Johnson', 'email': 'alice@example.com'}, ...]\nHas draft posts: True\n\n=== Statistics ===\n\nTotal posts: 3\nTotal views: 151\nAverage views: 50.3\nPublished posts: 2\n</code></pre>"},{"location":"getting-started/first-project/#step-6-add-transactions","title":"Step 6: Add Transactions","text":"<p>For operations that must succeed or fail together, use transactions:</p> <pre><code>from oxyde.db import transaction\n\n\nasync def transfer_post(post_id: int, new_author_id: int):\n    \"\"\"Transfer a post to a different author (atomic operation).\"\"\"\n    async with transaction.atomic():\n        # Get the post\n        post = await Post.objects.get(id=post_id)\n\n        # Verify new author exists\n        new_author = await Author.objects.get(id=new_author_id)\n\n        # Update the post\n        post.author_id = new_author_id\n        await post.save()\n\n        print(f\"Transferred '{post.title}' to {new_author.name}\")\n</code></pre> <p>If any operation fails, the entire transaction rolls back.</p>"},{"location":"getting-started/first-project/#step-7-add-joins","title":"Step 7: Add Joins","text":"<p>Load related data efficiently:</p> <pre><code>async def show_posts_with_authors():\n    \"\"\"Load posts with their authors in a single query.\"\"\"\n    posts = await Post.objects.join(\"author\").filter(published=True).all()\n\n    for post in posts:\n        print(f\"'{post.title}' by {post.author.name}\")\n</code></pre>"},{"location":"getting-started/first-project/#next-steps","title":"Next Steps","text":"<p>Now that you have a working project:</p> <ul> <li>Models \u2014 Learn all field types and options</li> <li>Filtering \u2014 Master the filter syntax</li> <li>Transactions \u2014 Understand transaction handling</li> <li>Relations \u2014 Work with foreign keys and joins</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>Rust 1.75+ (for building from source)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install oxyde\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>If you need to build from source (e.g., for development or customization):</p>"},{"location":"getting-started/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/mr-fatalyst/oxyde.git\ncd oxyde\n</code></pre>"},{"location":"getting-started/installation/#2-create-virtual-environment","title":"2. Create Virtual Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate     # Windows\n</code></pre>"},{"location":"getting-started/installation/#3-build-rust-core","title":"3. Build Rust Core","text":"<pre><code># Build the Rust workspace\ncargo build --release\n\n# Install the Python extension (PyO3 bindings)\ncd crates/oxyde-core-py\npip install maturin\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#4-install-python-package","title":"4. Install Python Package","text":"<pre><code>cd ../../python\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import oxyde\nprint(oxyde.__version__)\n</code></pre>"},{"location":"getting-started/installation/#database-drivers","title":"Database Drivers","text":"<p>Oxyde uses SQLx under the hood. Database drivers are included \u2014 no additional installation required.</p> Database Connection URL PostgreSQL <code>postgresql://user:pass@host:5432/db</code> SQLite <code>sqlite:///path/to/file.db</code> or <code>sqlite:///:memory:</code> MySQL <code>mysql://user:pass@host:3306/db</code>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start \u2014 Build your first app in 5 minutes</li> <li>First Project \u2014 Complete tutorial with a real example</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you up and running with Oxyde from scratch.</p>"},{"location":"getting-started/quickstart/#1-install-oxyde","title":"1. Install Oxyde","text":"<pre><code>pip install oxyde\n</code></pre>"},{"location":"getting-started/quickstart/#2-project-structure","title":"2. Project Structure","text":"<pre><code>myproject/\n\u251c\u2500\u2500 models.py          # Your Model classes\n\u251c\u2500\u2500 oxyde_config.py    # Generated by oxyde init\n\u251c\u2500\u2500 migrations/        # Generated migration files\n\u2514\u2500\u2500 main.py            # Your application\n</code></pre>"},{"location":"getting-started/quickstart/#3-initialize-configuration","title":"3. Initialize Configuration","text":"<p>Run the interactive setup:</p> <pre><code>oxyde init\n</code></pre> <p>You'll be prompted for:</p> <ul> <li>Models module(s) \u2014 Python modules with your models (e.g., <code>models</code>)</li> <li>Dialect \u2014 Database type: <code>postgres</code>, <code>sqlite</code>, or <code>mysql</code></li> <li>Database URL \u2014 Connection string (e.g., <code>sqlite:///app.db</code>)</li> <li>Migrations directory \u2014 Where to store migrations (default: <code>migrations</code>)</li> </ul> <p>This creates <code>oxyde_config.py</code>:</p> <pre><code>\"\"\"Oxyde ORM configuration.\"\"\"\n\nMODELS = [\"models\"]\nDIALECT = \"sqlite\"\nMIGRATIONS_DIR = \"migrations\"\nDATABASES = {\n    \"default\": \"sqlite:///app.db\",\n}\n</code></pre> <p>SQLite paths</p> <p>SQLite relative paths are resolved from the current working directory. For portable projects, see SQLite File Paths.</p>"},{"location":"getting-started/quickstart/#4-define-models","title":"4. Define Models","text":"<p>Create <code>models.py</code>:</p> <pre><code>from oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n    age: int | None = Field(default=None)\n\n    class Meta:\n        is_table = True\n        table_name = \"users\"\n</code></pre> <p>Key points:</p> <ul> <li>Inherit from <code>Model</code></li> <li>Set <code>is_table = True</code> in <code>Meta</code> class</li> <li>Use <code>Field()</code> for database constraints</li> <li><code>db_pk=True</code> marks the primary key</li> <li><code>db_unique=True</code> creates a UNIQUE constraint</li> </ul>"},{"location":"getting-started/quickstart/#5-create-and-apply-migrations","title":"5. Create and Apply Migrations","text":"<p>Generate migration from your models:</p> <pre><code>oxyde makemigrations\n</code></pre> <p>Output: <pre><code>\ud83d\udce6 Loading models from: ['models']\n\u2705 Created migration: migrations/0001_initial.py\n</code></pre></p> <p>Apply the migration to create tables:</p> <pre><code>oxyde migrate\n</code></pre> <p>Output: <pre><code>\ud83d\udce6 Loading models from: ['models']\n\ud83d\udd04 Applying 0001_initial... \u2705\n</code></pre></p>"},{"location":"getting-started/quickstart/#6-write-your-application","title":"6. Write Your Application","text":"<p>Create <code>main.py</code>:</p> <pre><code>import asyncio\nfrom oxyde import db\nfrom models import User\n\nasync def main():\n    # Connect using config from oxyde_config.py\n    await db.init(default=\"sqlite:///app.db\")\n\n    # Create\n    alice = await User.objects.create(\n        name=\"Alice\",\n        email=\"alice@example.com\",\n        age=30\n    )\n    print(f\"Created user: {alice.name} (id={alice.id})\")\n\n    # Read\n    users = await User.objects.filter(age__gte=25).all()\n    print(f\"Found {len(users)} users aged 25+\")\n\n    # Update\n    alice.age = 31\n    await alice.save()\n\n    # Delete\n    await alice.delete()\n\n    # Close connection\n    await db.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Run it:</p> <pre><code>python main.py\n</code></pre>"},{"location":"getting-started/quickstart/#crud-operations-reference","title":"CRUD Operations Reference","text":""},{"location":"getting-started/quickstart/#create","title":"Create","text":"<pre><code># Via manager\nuser = await User.objects.create(name=\"Alice\", email=\"alice@example.com\")\n\n# Via instance\nuser = User(name=\"Bob\", email=\"bob@example.com\")\nawait user.save()\n</code></pre>"},{"location":"getting-started/quickstart/#read","title":"Read","text":"<pre><code># Get all\nusers = await User.objects.all()\n\n# Get by ID (raises NotFoundError if not found)\nuser = await User.objects.get(id=1)\n\n# Get or None\nuser = await User.objects.get_or_none(id=999)\n\n# Filter\nadults = await User.objects.filter(age__gte=18).all()\n\n# First/Last\nfirst = await User.objects.first()\nlast = await User.objects.last()\n</code></pre>"},{"location":"getting-started/quickstart/#update","title":"Update","text":"<pre><code># Via instance\nuser = await User.objects.get(id=1)\nuser.name = \"Alice Smith\"\nawait user.save()\n\n# Bulk update (returns updated rows)\nrows = await User.objects.filter(age__lt=18).update(status=\"minor\")\n</code></pre>"},{"location":"getting-started/quickstart/#delete","title":"Delete","text":"<pre><code># Via instance\nuser = await User.objects.get(id=1)\nawait user.delete()\n\n# Bulk delete\ncount = await User.objects.filter(status=\"inactive\").delete()\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Models \u2014 Fields, constraints, indexes</li> <li>Queries \u2014 Filtering, ordering, aggregation</li> <li>Transactions \u2014 Atomic operations</li> <li>FastAPI Integration \u2014 Using Oxyde with FastAPI</li> </ul>"},{"location":"guide/aggregation/","title":"Aggregation","text":"<p>Oxyde supports SQL aggregate functions and GROUP BY operations.</p>"},{"location":"guide/aggregation/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"guide/aggregation/#direct-aggregates","title":"Direct Aggregates","text":"<p>Execute aggregate queries directly:</p> <pre><code># COUNT\ncount = await User.objects.count()\nactive_count = await User.objects.filter(status=\"active\").count()\n\n# SUM\ntotal = await Order.objects.sum(\"amount\")\n\n# AVG\naverage = await User.objects.avg(\"age\")\n\n# MAX / MIN\nhighest = await Product.objects.max(\"price\")\nlowest = await Product.objects.min(\"price\")\n</code></pre>"},{"location":"guide/aggregation/#aggregate-classes","title":"Aggregate Classes","text":"<p>For more control, use aggregate classes:</p> <pre><code>from oxyde import Count, Sum, Avg, Max, Min\n\n# With distinct\nunique_count = await User.objects.annotate(\n    unique_cities=Count(\"city\", distinct=True)\n).all()\n</code></pre>"},{"location":"guide/aggregation/#available-aggregates","title":"Available Aggregates","text":"Function Description Example <code>Count</code> Count rows <code>Count(\"*\")</code>, <code>Count(\"id\", distinct=True)</code> <code>Sum</code> Sum values <code>Sum(\"amount\")</code> <code>Avg</code> Average <code>Avg(\"price\")</code> <code>Max</code> Maximum <code>Max(\"created_at\")</code> <code>Min</code> Minimum <code>Min(\"price\")</code>"},{"location":"guide/aggregation/#annotate","title":"annotate()","text":"<p>Add computed columns to query results:</p> <pre><code>from oxyde import Count\n\n# Single annotation\nresults = await User.objects.annotate(\n    post_count=Count(\"id\")\n).all()\n\n# Multiple annotations\nresults = await Order.objects.annotate(\n    total=Sum(\"amount\"),\n    avg_item=Avg(\"amount\"),\n).all()\n</code></pre>"},{"location":"guide/aggregation/#group-by","title":"GROUP BY","text":"<p>Group results by one or more columns:</p> <pre><code># Posts per author\nresults = await Post.objects.values(\"author_id\").annotate(\n    count=Count(\"*\")\n).group_by(\"author_id\").all()\n\n# Result: [{\"author_id\": 1, \"count\": 5}, {\"author_id\": 2, \"count\": 3}]\n</code></pre>"},{"location":"guide/aggregation/#multiple-group-columns","title":"Multiple Group Columns","text":"<pre><code># Sales by year and month\nresults = await Order.objects.values(\"year\", \"month\").annotate(\n    total=Sum(\"amount\"),\n    orders=Count(\"*\")\n).group_by(\"year\", \"month\").all()\n</code></pre>"},{"location":"guide/aggregation/#with-filtering","title":"With Filtering","text":"<pre><code># Active users per city\nresults = await User.objects.filter(\n    status=\"active\"\n).values(\"city\").annotate(\n    count=Count(\"*\")\n).group_by(\"city\").all()\n</code></pre>"},{"location":"guide/aggregation/#having","title":"HAVING","text":"<p>Filter on aggregate results:</p> <pre><code># Authors with more than 5 posts\nresults = await Post.objects.values(\"author_id\").annotate(\n    count=Count(\"*\")\n).group_by(\"author_id\").having(count__gt=5).all()\n</code></pre> <p>HAVING vs WHERE</p> <ul> <li><code>filter()</code> \u2192 WHERE (filters rows before grouping)</li> <li><code>having()</code> \u2192 HAVING (filters groups after aggregation)</li> </ul>"},{"location":"guide/aggregation/#complex-having","title":"Complex HAVING","text":"<pre><code># High-value customers (total orders &gt; $1000)\nresults = await Order.objects.values(\"customer_id\").annotate(\n    total=Sum(\"amount\")\n).group_by(\"customer_id\").having(total__gte=1000).all()\n</code></pre>"},{"location":"guide/aggregation/#ordering-aggregates","title":"Ordering Aggregates","text":"<p>Order by aggregate values:</p> <pre><code># Top authors by post count\nresults = await Post.objects.values(\"author_id\").annotate(\n    count=Count(\"*\")\n).group_by(\"author_id\").order_by(\"-count\").limit(10).all()\n</code></pre>"},{"location":"guide/aggregation/#scalar-functions","title":"Scalar Functions","text":""},{"location":"guide/aggregation/#concat","title":"Concat","text":"<p>Concatenate string fields:</p> <pre><code>from oxyde import Concat\n\nresults = await User.objects.annotate(\n    full_name=Concat(\"first_name\", \"last_name\", separator=\" \")\n).all()\n</code></pre>"},{"location":"guide/aggregation/#coalesce","title":"Coalesce","text":"<p>Return first non-NULL value:</p> <pre><code>from oxyde import Coalesce\n\nresults = await User.objects.annotate(\n    display_name=Coalesce(\"nickname\", \"username\", \"email\")\n).all()\n</code></pre>"},{"location":"guide/aggregation/#rawsql","title":"RawSQL","text":"<p>For unsupported functions, use raw SQL:</p> <pre><code>from oxyde import RawSQL\n\nresults = await User.objects.annotate(\n    name_length=RawSQL(\"LENGTH(name)\")\n).all()\n</code></pre> <p>SQL Injection</p> <p>Be careful with user input in RawSQL. Never interpolate user data directly.</p>"},{"location":"guide/aggregation/#examples","title":"Examples","text":""},{"location":"guide/aggregation/#leaderboard","title":"Leaderboard","text":"<pre><code># Top 10 players by score\nleaderboard = await Score.objects.values(\"user_id\").annotate(\n    total=Sum(\"points\")\n).group_by(\"user_id\").order_by(\"-total\").limit(10).all()\n</code></pre>"},{"location":"guide/aggregation/#sales-report","title":"Sales Report","text":"<pre><code># Daily sales totals\nfrom datetime import date\n\nreport = await Order.objects.filter(\n    created_at__gte=date(2024, 1, 1)\n).values(\"date\").annotate(\n    orders=Count(\"*\"),\n    revenue=Sum(\"total\"),\n    avg_order=Avg(\"total\")\n).group_by(\"date\").order_by(\"date\").all()\n</code></pre>"},{"location":"guide/aggregation/#category-statistics","title":"Category Statistics","text":"<pre><code># Products per category with price stats\nstats = await Product.objects.values(\"category_id\").annotate(\n    count=Count(\"*\"),\n    avg_price=Avg(\"price\"),\n    min_price=Min(\"price\"),\n    max_price=Max(\"price\")\n).group_by(\"category_id\").all()\n</code></pre>"},{"location":"guide/aggregation/#user-activity","title":"User Activity","text":"<pre><code># Most active users (by login count)\nactive_users = await LoginLog.objects.values(\"user_id\").annotate(\n    logins=Count(\"*\")\n).group_by(\"user_id\").having(logins__gte=10).order_by(\"-logins\").all()\n</code></pre>"},{"location":"guide/aggregation/#time-based-grouping","title":"Time-based Grouping","text":"<pre><code># Orders by year\nyearly = await Order.objects.filter(\n    created_at__year=2024\n).values(\"created_at__year\", \"created_at__month\").annotate(\n    count=Count(\"*\"),\n    total=Sum(\"amount\")\n).group_by(\"created_at__year\", \"created_at__month\").all()\n</code></pre>"},{"location":"guide/aggregation/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom oxyde import Model, Field, db, Count, Sum, Avg\n\nclass Order(Model):\n    class Meta:\n        is_table = True\n\n    id: int | None = Field(default=None, db_pk=True)\n    customer_id: int\n    amount: float\n    status: str\n\nasync def main():\n    async with db.connect(\"sqlite:///orders.db\"):\n        # Total orders and revenue\n        total_orders = await Order.objects.count()\n        total_revenue = await Order.objects.sum(\"amount\")\n        print(f\"Orders: {total_orders}, Revenue: ${total_revenue}\")\n\n        # Revenue by status\n        by_status = await Order.objects.values(\"status\").annotate(\n            count=Count(\"*\"),\n            total=Sum(\"amount\")\n        ).group_by(\"status\").all()\n\n        for row in by_status:\n            print(f\"{row['status']}: {row['count']} orders, ${row['total']}\")\n\n        # Top customers\n        top = await Order.objects.values(\"customer_id\").annotate(\n            orders=Count(\"*\"),\n            spent=Sum(\"amount\")\n        ).group_by(\"customer_id\").order_by(\"-spent\").limit(5).all()\n\n        print(\"\\nTop customers:\")\n        for row in top:\n            print(f\"Customer {row['customer_id']}: ${row['spent']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/aggregation/#next-steps","title":"Next Steps","text":"<ul> <li>Relations \u2014 Foreign keys and joins</li> <li>Transactions \u2014 Atomic operations</li> <li>Queries \u2014 Full query reference</li> </ul>"},{"location":"guide/connections/","title":"Database Connections","text":"<p>Oxyde provides multiple ways to manage database connections.</p>"},{"location":"guide/connections/#quick-start","title":"Quick Start","text":"<pre><code>from oxyde import db\n\n# Initialize\nawait db.init(default=\"postgresql://localhost/mydb\")\n\n# Use models\nusers = await User.objects.all()\n\n# Close\nawait db.close()\n</code></pre>"},{"location":"guide/connections/#connection-urls","title":"Connection URLs","text":"Database URL Format PostgreSQL <code>postgresql://user:pass@host:5432/database</code> PostgreSQL <code>postgres://user:pass@host:5432/database</code> SQLite (file) <code>sqlite:///path/to/file.db</code> SQLite (memory) <code>sqlite:///:memory:</code> MySQL <code>mysql://user:pass@host:3306/database</code> <p>SQLite File Paths</p> <p>SQLite relative paths (like <code>sqlite:///app.db</code>) are resolved from the current working directory, not from the config file location. For portable projects, use absolute paths:</p> <pre><code># oxyde_config.py\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\n\nDATABASES = {\n    \"default\": f\"sqlite:///{BASE_DIR}/app.db\"\n}\n</code></pre>"},{"location":"guide/connections/#high-level-api","title":"High-Level API","text":""},{"location":"guide/connections/#dbinit","title":"db.init()","text":"<p>Initialize one or more database connections:</p> <pre><code>from oxyde import db, PoolSettings\n\n# Single database\nawait db.init(default=\"postgresql://localhost/mydb\")\n\n# Multiple databases\nawait db.init(\n    default=\"postgresql://localhost/main\",\n    analytics=\"postgresql://localhost/analytics\",\n    cache=\"sqlite:///:memory:\",\n)\n\n# With custom settings\nawait db.init(\n    default=\"postgresql://localhost/mydb\",\n    settings=PoolSettings(max_connections=20),\n)\n</code></pre>"},{"location":"guide/connections/#dbclose","title":"db.close()","text":"<p>Close all connections gracefully:</p> <pre><code>await db.close()\n</code></pre> <p>This rolls back any active transactions before closing.</p>"},{"location":"guide/connections/#dbconnect","title":"db.connect()","text":"<p>Context manager for scripts and tests:</p> <pre><code>async with db.connect(\"sqlite:///:memory:\") as conn:\n    users = await User.objects.all()\n# Connection closed automatically\n</code></pre> <p>With custom name:</p> <pre><code>async with db.connect(\"sqlite:///test.db\", name=\"test\") as conn:\n    users = await User.objects.all(using=\"test\")\n</code></pre>"},{"location":"guide/connections/#dblifespan","title":"db.lifespan()","text":"<p>FastAPI integration:</p> <pre><code>from fastapi import FastAPI\nfrom oxyde import db\n\napp = FastAPI(\n    lifespan=db.lifespan(\n        default=\"postgresql://localhost/mydb\",\n        settings=PoolSettings(max_connections=50),\n    )\n)\n\n@app.get(\"/users\")\nasync def get_users():\n    return await User.objects.all()\n</code></pre>"},{"location":"guide/connections/#asyncdatabase","title":"AsyncDatabase","text":"<p>Low-level connection wrapper:</p> <pre><code>from oxyde import AsyncDatabase, PoolSettings\n\ndatabase = AsyncDatabase(\n    \"postgresql://localhost/mydb\",\n    name=\"default\",\n    settings=PoolSettings(max_connections=20),\n)\n\n# Manual lifecycle\nawait database.connect()\n# ... use database ...\nawait database.disconnect()\n\n# Or as context manager\nasync with database:\n    users = await User.objects.all()\n</code></pre>"},{"location":"guide/connections/#pool-settings","title":"Pool Settings","text":"<p>Configure connection pool behavior:</p> <pre><code>from oxyde import PoolSettings\nfrom datetime import timedelta\n\nsettings = PoolSettings(\n    # Pool size\n    max_connections=20,           # Maximum pool size\n    min_connections=5,            # Minimum idle connections\n\n    # Timeouts\n    acquire_timeout=30.0,         # Max wait for connection (seconds)\n    idle_timeout=600.0,           # Close idle connections after (seconds)\n    max_lifetime=1800.0,          # Max connection age (seconds)\n\n    # Health check\n    test_before_acquire=True,     # Ping before using connection\n\n    # Transaction cleanup (background task)\n    transaction_timeout=300,      # Max transaction age (seconds)\n    transaction_cleanup_interval=60,  # Cleanup check interval (seconds)\n)\n</code></pre>"},{"location":"guide/connections/#sqlite-settings","title":"SQLite Settings","text":"<p>SQLite-specific PRAGMA settings (applied automatically):</p> <pre><code>settings = PoolSettings(\n    # WAL mode for better concurrent writes (10-20x faster)\n    sqlite_journal_mode=\"WAL\",\n\n    # Balance between speed and safety\n    sqlite_synchronous=\"NORMAL\",\n\n    # Cache size in pages (~10MB)\n    sqlite_cache_size=10000,\n\n    # Lock timeout in milliseconds\n    sqlite_busy_timeout=5000,\n)\n</code></pre> <p>Default settings are optimized for most use cases.</p>"},{"location":"guide/connections/#multiple-databases","title":"Multiple Databases","text":""},{"location":"guide/connections/#configuration","title":"Configuration","text":"<pre><code>await db.init(\n    default=\"postgresql://localhost/main\",\n    analytics=\"postgresql://localhost/analytics\",\n    legacy=\"mysql://localhost/old_system\",\n)\n</code></pre>"},{"location":"guide/connections/#using-specific-database","title":"Using Specific Database","text":"<pre><code># Default database\nusers = await User.objects.all()\n\n# Specific database\nevents = await Event.objects.all(using=\"analytics\")\nold_users = await LegacyUser.objects.all(using=\"legacy\")\n</code></pre>"},{"location":"guide/connections/#transactions-across-databases","title":"Transactions Across Databases","text":"<p>Each database has separate transactions:</p> <pre><code>from oxyde.db import transaction\n\n# Transaction on default database\nasync with transaction.atomic():\n    await User.objects.create(name=\"Alice\")\n\n# Transaction on analytics database\nasync with transaction.atomic(using=\"analytics\"):\n    await Event.objects.create(type=\"signup\")\n</code></pre>"},{"location":"guide/connections/#connection-registry","title":"Connection Registry","text":""},{"location":"guide/connections/#get-connection-by-name","title":"Get Connection by Name","text":"<pre><code>from oxyde import get_connection\n\nconn = await get_connection(\"default\")\nprint(conn.connected)  # True\n</code></pre>"},{"location":"guide/connections/#register-custom-connection","title":"Register Custom Connection","text":"<pre><code>from oxyde import AsyncDatabase, register_connection\n\ndatabase = AsyncDatabase(\"postgresql://localhost/custom\", name=\"custom\")\nregister_connection(database)\nawait database.connect()\n\n# Now available as \"custom\"\nusers = await User.objects.all(using=\"custom\")\n</code></pre>"},{"location":"guide/connections/#disconnect-all","title":"Disconnect All","text":"<pre><code>from oxyde import disconnect_all\n\nawait disconnect_all()  # Close all registered connections\n</code></pre>"},{"location":"guide/connections/#error-handling","title":"Error Handling","text":"<pre><code>from oxyde import db\nfrom oxyde.exceptions import ManagerError\n\ntry:\n    await db.init(default=\"postgresql://invalid-host/db\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n</code></pre>"},{"location":"guide/connections/#best-practices","title":"Best Practices","text":""},{"location":"guide/connections/#1-use-context-managers-for-scripts","title":"1. Use Context Managers for Scripts","text":"<pre><code>async def main():\n    async with db.connect(\"sqlite:///app.db\"):\n        # Automatic cleanup on exit\n        await run_app()\n</code></pre>"},{"location":"guide/connections/#2-use-lifespan-for-web-apps","title":"2. Use Lifespan for Web Apps","text":"<pre><code>app = FastAPI(lifespan=db.lifespan(default=\"postgresql://...\"))\n</code></pre>"},{"location":"guide/connections/#3-configure-pool-size-based-on-workload","title":"3. Configure Pool Size Based on Workload","text":"<pre><code># Web API: many short connections\nPoolSettings(max_connections=50, min_connections=10)\n\n# Background worker: fewer long connections\nPoolSettings(max_connections=10, min_connections=2)\n\n# SQLite: single connection is usually enough\nPoolSettings(max_connections=1)\n</code></pre>"},{"location":"guide/connections/#4-set-appropriate-timeouts","title":"4. Set Appropriate Timeouts","text":"<pre><code># Production\nPoolSettings(\n    acquire_timeout=30,      # Don't wait forever\n    idle_timeout=300,        # Close idle after 5 min\n    max_lifetime=3600,       # Refresh connections hourly\n)\n</code></pre>"},{"location":"guide/connections/#advanced-multiple-databases","title":"Advanced: Multiple Databases","text":""},{"location":"guide/connections/#per-database-settings","title":"Per-Database Settings","text":"<pre><code>from oxyde import AsyncDatabase, PoolSettings\n\n# Main database: high concurrency\nmain_db = AsyncDatabase(\n    \"postgresql://localhost/main\",\n    name=\"default\",\n    settings=PoolSettings(\n        max_connections=50,\n        min_connections=10,\n    ),\n)\n\n# Analytics: read-heavy, fewer connections\nanalytics_db = AsyncDatabase(\n    \"postgresql://localhost/analytics\",\n    name=\"analytics\",\n    settings=PoolSettings(\n        max_connections=10,\n        min_connections=2,\n    ),\n)\n\nawait main_db.connect()\nawait analytics_db.connect()\n</code></pre>"},{"location":"guide/connections/#read-replicas","title":"Read Replicas","text":"<pre><code>await db.init(\n    default=\"postgresql://primary/db\",\n    replica=\"postgresql://replica/db\",\n)\n\nasync def get_user(user_id: int):\n    # Read from replica\n    return await User.objects.get(id=user_id, using=\"replica\")\n\nasync def update_user(user_id: int, **data):\n    # Write to primary\n    await User.objects.filter(id=user_id).update(**data)\n</code></pre>"},{"location":"guide/connections/#cross-database-operations","title":"Cross-Database Operations","text":"<pre><code>async def sync_user_to_analytics(user_id: int):\n    # Read from main\n    user = await User.objects.get(id=user_id)\n\n    # Write to analytics\n    await UserProfile.objects.create(\n        user_id=user.id,\n        name=user.name,\n        using=\"analytics\"\n    )\n</code></pre>"},{"location":"guide/connections/#dynamic-tenant-connections","title":"Dynamic Tenant Connections","text":"<pre><code>from oxyde import AsyncDatabase\n\nclass TenantConnectionPool:\n    def __init__(self):\n        self._connections: dict[int, AsyncDatabase] = {}\n\n    async def get_connection(self, tenant_id: int) -&gt; AsyncDatabase:\n        if tenant_id not in self._connections:\n            tenant = await Tenant.objects.get(id=tenant_id)\n            conn = AsyncDatabase(\n                tenant.database_url,\n                name=f\"tenant_{tenant_id}\",\n            )\n            await conn.connect()\n            self._connections[tenant_id] = conn\n        return self._connections[tenant_id]\n\n    async def close_all(self):\n        for conn in self._connections.values():\n            await conn.disconnect()\n        self._connections.clear()\n\ntenant_pool = TenantConnectionPool()\n</code></pre>"},{"location":"guide/connections/#fastapi-with-multiple-databases","title":"FastAPI with Multiple Databases","text":"<pre><code>from fastapi import FastAPI, Depends, Request\nfrom oxyde import db, PoolSettings\n\napp = FastAPI(\n    lifespan=db.lifespan(\n        default=\"postgresql://localhost/main\",\n        analytics=\"postgresql://localhost/analytics\",\n        settings=PoolSettings(max_connections=20),\n    )\n)\n\n@app.get(\"/users\")\nasync def get_users():\n    return await User.objects.all()\n\n@app.get(\"/events\")\nasync def get_events():\n    return await Event.objects.all(using=\"analytics\")\n</code></pre>"},{"location":"guide/connections/#testing-with-multiple-databases","title":"Testing with Multiple Databases","text":"<pre><code>import pytest\n\n@pytest.fixture\nasync def test_dbs():\n    await db.init(\n        default=\"sqlite:///:memory:\",\n        analytics=\"sqlite:///:memory:\",\n    )\n    yield\n    await db.close()\n\n@pytest.mark.asyncio\nasync def test_cross_db(test_dbs):\n    user = await User.objects.create(name=\"Test\")\n    await Event.objects.create(\n        type=\"test\",\n        user_id=user.id,\n        using=\"analytics\"\n    )\n\n    events = await Event.objects.filter(user_id=user.id).all(using=\"analytics\")\n    assert len(events) == 1\n</code></pre>"},{"location":"guide/connections/#next-steps","title":"Next Steps","text":"<ul> <li>Queries \u2014 Query your models</li> <li>Transactions \u2014 Transaction handling</li> </ul>"},{"location":"guide/exceptions/","title":"Exceptions API Reference","text":"<p>Complete reference for Oxyde exception hierarchy.</p>"},{"location":"guide/exceptions/#overview","title":"Overview","text":"<p>All Oxyde exceptions inherit from <code>OxydeError</code>, allowing catch-all handling:</p> <pre><code>from oxyde import OxydeError\n\ntry:\n    user = await User.objects.get(id=999)\nexcept OxydeError as e:\n    print(f\"ORM error: {e}\")\n</code></pre>"},{"location":"guide/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>OxydeError (base)\n\u251c\u2500\u2500 FieldError                - Invalid field definition or access\n\u251c\u2500\u2500 FieldLookupError          - Unknown lookup operator\n\u2502   \u2514\u2500\u2500 FieldLookupValueError - Invalid value for lookup\n\u2514\u2500\u2500 ManagerError              - Query execution errors\n    \u251c\u2500\u2500 NotFoundError         - get() returned no rows\n    \u251c\u2500\u2500 MultipleObjectsReturned - get() returned multiple rows\n    \u2514\u2500\u2500 IntegrityError        - Constraint violation\n</code></pre>"},{"location":"guide/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"guide/exceptions/#oxydeerror","title":"OxydeError","text":"<pre><code>class OxydeError(Exception):\n    \"\"\"Base exception for all Oxyde-related errors.\"\"\"\n</code></pre> <p>Catch this to handle any Oxyde error:</p> <pre><code>try:\n    await some_orm_operation()\nexcept OxydeError as e:\n    logger.error(f\"Database operation failed: {e}\")\n    raise HTTPException(500, \"Internal server error\")\n</code></pre>"},{"location":"guide/exceptions/#field-errors","title":"Field Errors","text":""},{"location":"guide/exceptions/#fielderror","title":"FieldError","text":"<pre><code>class FieldError(OxydeError):\n    \"\"\"Raised when a model field is invalid or missing.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li>Accessing non-existent field in filter</li> <li>Invalid field in <code>update_fields</code></li> <li>Field metadata parsing errors</li> </ul> <pre><code>try:\n    await User.objects.filter(nonexistent_field=\"value\").all()\nexcept FieldError as e:\n    print(f\"Field error: {e}\")\n    # \"User has no field 'nonexistent_field'\"\n</code></pre> <pre><code>try:\n    user = await User.objects.get(id=1)\n    await user.save(update_fields=[\"invalid_field\"])\nexcept FieldError as e:\n    print(f\"Invalid field: {e}\")\n</code></pre>"},{"location":"guide/exceptions/#lookup-errors","title":"Lookup Errors","text":""},{"location":"guide/exceptions/#fieldlookuperror","title":"FieldLookupError","text":"<pre><code>class FieldLookupError(OxydeError):\n    \"\"\"Raised when an unsupported field lookup is requested.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li>Using unknown lookup suffix (e.g., <code>__xyz</code>)</li> </ul> <pre><code>try:\n    await User.objects.filter(name__unknown=\"value\").all()\nexcept FieldLookupError as e:\n    print(f\"Lookup error: {e}\")\n    # \"Unsupported lookup 'unknown' for field 'name'\"\n</code></pre>"},{"location":"guide/exceptions/#fieldlookupvalueerror","title":"FieldLookupValueError","text":"<pre><code>class FieldLookupValueError(FieldLookupError):\n    \"\"\"Raised when the lookup value is not compatible with the operator.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li><code>__in</code> with non-iterable value</li> <li><code>__in</code> with string value (likely mistake)</li> <li><code>__gte</code>/<code>__lte</code> with None</li> <li><code>__contains</code> with non-string</li> <li><code>__between</code> with wrong tuple size</li> </ul> <pre><code>try:\n    await User.objects.filter(id__in=\"not_a_list\").all()\nexcept FieldLookupValueError as e:\n    print(f\"Value error: {e}\")\n    # \"Lookup 'in' does not accept string values; use a sequence\"\n</code></pre> <pre><code>try:\n    await User.objects.filter(age__gte=None).all()\nexcept FieldLookupValueError as e:\n    print(f\"Value error: {e}\")\n    # \"Lookup 'gte' requires a non-null value\"\n</code></pre> <pre><code>try:\n    await User.objects.filter(age__between=(18,)).all()\nexcept FieldLookupValueError as e:\n    print(f\"Value error: {e}\")\n    # \"Lookup 'between' requires a tuple/list of two values\"\n</code></pre>"},{"location":"guide/exceptions/#manager-errors","title":"Manager Errors","text":""},{"location":"guide/exceptions/#managererror","title":"ManagerError","text":"<pre><code>class ManagerError(OxydeError):\n    \"\"\"Raised for issues inside the ORM manager layer.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li>General query execution failures</li> <li>Invalid query construction</li> <li>Missing required parameters</li> </ul> <pre><code>try:\n    await User.objects.create()  # No data provided\nexcept ManagerError as e:\n    print(f\"Manager error: {e}\")\n    # \"create() requires an instance or field values\"\n</code></pre> <pre><code>try:\n    user = User(name=\"Test\")  # No PK\n    await user.delete()\nexcept ManagerError as e:\n    print(f\"Manager error: {e}\")\n    # \"delete() requires the instance to have a primary key value\"\n</code></pre>"},{"location":"guide/exceptions/#notfounderror","title":"NotFoundError","text":"<pre><code>class NotFoundError(ManagerError):\n    \"\"\"Raised when a query expecting a single row finds none.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li><code>get()</code> finds no matching rows</li> <li><code>save()</code> update finds no matching row</li> </ul> <pre><code>try:\n    user = await User.objects.get(id=999999)\nexcept NotFoundError as e:\n    print(f\"Not found: {e}\")\n    # \"User matching query not found\"\n</code></pre> <p>Common pattern:</p> <pre><code># Option 1: Use get_or_none\nuser = await User.objects.get_or_none(id=user_id)\nif user is None:\n    return {\"error\": \"User not found\"}\n\n# Option 2: Catch exception\ntry:\n    user = await User.objects.get(id=user_id)\nexcept NotFoundError:\n    raise HTTPException(404, \"User not found\")\n</code></pre>"},{"location":"guide/exceptions/#multipleobjectsreturned","title":"MultipleObjectsReturned","text":"<pre><code>class MultipleObjectsReturned(ManagerError):\n    \"\"\"Raised when a query expecting a single row finds more than one.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li><code>get()</code> finds multiple matching rows</li> </ul> <pre><code>try:\n    user = await User.objects.get(status=\"active\")  # Many active users!\nexcept MultipleObjectsReturned as e:\n    print(f\"Multiple found: {e}\")\n    # \"Query for User returned multiple objects\"\n</code></pre> <p>Prevention:</p> <pre><code># Use unique fields for get()\nuser = await User.objects.get(email=\"alice@example.com\")\n\n# Or use first() for non-unique queries\nuser = await User.objects.filter(status=\"active\").first()\n</code></pre>"},{"location":"guide/exceptions/#integrityerror","title":"IntegrityError","text":"<pre><code>class IntegrityError(ManagerError):\n    \"\"\"Raised when database integrity constraints are violated.\"\"\"\n</code></pre> <p>When raised:</p> <ul> <li>Primary key violation (duplicate PK)</li> <li>Unique constraint violation</li> <li>Foreign key constraint violation</li> <li>Check constraint violation</li> </ul> <pre><code>try:\n    await User.objects.create(email=\"duplicate@example.com\")\nexcept IntegrityError as e:\n    print(f\"Constraint violation: {e}\")\n    # May contain: \"UNIQUE constraint failed: users.email\"\n</code></pre> <p>Common patterns:</p> <pre><code># Handle duplicate key\ntry:\n    user = await User.objects.create(email=email)\nexcept IntegrityError:\n    user = await User.objects.get(email=email)\n\n# Or use get_or_create\nuser, created = await User.objects.get_or_create(\n    email=email,\n    defaults={\"name\": name}\n)\n</code></pre>"},{"location":"guide/exceptions/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"guide/exceptions/#api-endpoint-pattern","title":"API Endpoint Pattern","text":"<pre><code>from fastapi import HTTPException\nfrom oxyde import NotFoundError, IntegrityError, OxydeError\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    try:\n        return await User.objects.get(id=user_id)\n    except NotFoundError:\n        raise HTTPException(404, \"User not found\")\n\n@app.post(\"/users\")\nasync def create_user(data: UserCreate):\n    try:\n        return await User.objects.create(**data.model_dump())\n    except IntegrityError:\n        raise HTTPException(409, \"User already exists\")\n    except OxydeError as e:\n        raise HTTPException(500, str(e))\n</code></pre>"},{"location":"guide/exceptions/#transaction-rollback-pattern","title":"Transaction Rollback Pattern","text":"<pre><code>from oxyde import IntegrityError\nfrom oxyde.db import transaction\n\nasync def transfer(from_id: int, to_id: int, amount: Decimal):\n    try:\n        async with transaction.atomic():\n            from_user = await User.objects.filter(id=from_id).for_update().first()\n            to_user = await User.objects.filter(id=to_id).for_update().first()\n\n            if from_user is None or to_user is None:\n                raise NotFoundError(\"User not found\")\n\n            if from_user.balance &lt; amount:\n                raise ValueError(\"Insufficient balance\")\n\n            await User.objects.filter(id=from_id).update(balance=F(\"balance\") - amount)\n            await User.objects.filter(id=to_id).update(balance=F(\"balance\") + amount)\n\n    except IntegrityError:\n        # Transaction automatically rolled back\n        raise ValueError(\"Transfer failed due to constraint violation\")\n</code></pre>"},{"location":"guide/exceptions/#graceful-degradation-pattern","title":"Graceful Degradation Pattern","text":"<pre><code>async def get_user_with_fallback(user_id: int) -&gt; User | None:\n    try:\n        return await User.objects.get(id=user_id)\n    except NotFoundError:\n        return None\n    except OxydeError as e:\n        logger.warning(f\"Database error: {e}\")\n        return await cache.get(f\"user:{user_id}\")\n</code></pre>"},{"location":"guide/exceptions/#import-reference","title":"Import Reference","text":"<pre><code>from oxyde import (\n    OxydeError,\n    FieldError,\n    FieldLookupError,\n    FieldLookupValueError,\n    ManagerError,\n    NotFoundError,\n    MultipleObjectsReturned,\n    IntegrityError,\n)\n</code></pre> <p>Or import from exceptions module:</p> <pre><code>from oxyde.exceptions import (\n    OxydeError,\n    FieldError,\n    FieldLookupError,\n    FieldLookupValueError,\n    ManagerError,\n    NotFoundError,\n    MultipleObjectsReturned,\n    IntegrityError,\n)\n</code></pre>"},{"location":"guide/exceptions/#next-steps","title":"Next Steps","text":"<ul> <li>Models \u2014 Model definition</li> <li>Queries \u2014 Query API</li> <li>Transactions \u2014 Transaction handling</li> </ul>"},{"location":"guide/expressions/","title":"F-Expressions","text":"<p>F expressions reference database columns for atomic operations executed entirely in the database.</p>"},{"location":"guide/expressions/#why-f-expressions","title":"Why F Expressions?","text":"<p>Without F expressions, you risk race conditions:</p> <pre><code># BAD: Race condition\npost = await Post.objects.get(id=1)\npost.views = post.views + 1  # Read old value\nawait post.save()            # Another request might have incremented too\n</code></pre> <p>With F expressions, the operation is atomic:</p> <pre><code># GOOD: Atomic\nfrom oxyde import F\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\n</code></pre> <p>The SQL generated is <code>UPDATE posts SET views = views + 1 WHERE id = 1</code>.</p>"},{"location":"guide/expressions/#basic-usage","title":"Basic Usage","text":"<pre><code>from oxyde import F\n\n# Reference a column\nF(\"views\")\n\n# Arithmetic\nF(\"views\") + 1\nF(\"price\") * 0.9\nF(\"balance\") - 100\nF(\"total\") / F(\"count\")\n</code></pre>"},{"location":"guide/expressions/#supported-operations","title":"Supported Operations","text":"Operation Example SQL Addition <code>F(\"x\") + 1</code> <code>x + 1</code> Subtraction <code>F(\"x\") - 1</code> <code>x - 1</code> Multiplication <code>F(\"x\") * 2</code> <code>x * 2</code> Division <code>F(\"x\") / 2</code> <code>x / 2</code> Negation <code>-F(\"x\")</code> <code>-x</code>"},{"location":"guide/expressions/#column-column","title":"Column + Column","text":"<p>Combine multiple columns:</p> <pre><code># total = price * quantity\nawait Order.objects.filter(id=1).update(total=F(\"price\") * F(\"quantity\"))\n\n# score = base_score + bonus\nawait Player.objects.filter(id=1).update(score=F(\"base_score\") + F(\"bonus\"))\n</code></pre>"},{"location":"guide/expressions/#use-with-update","title":"Use with update()","text":"<p>The most common use case:</p> <pre><code># Increment\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\n\n# Decrement\nawait Product.objects.filter(id=1).update(stock=F(\"stock\") - 1)\n\n# Percentage increase\nawait Product.objects.filter(category=\"sale\").update(\n    price=F(\"price\") * 1.1  # 10% increase\n)\n\n# Percentage discount\nawait Product.objects.filter(category=\"clearance\").update(\n    price=F(\"price\") * 0.5  # 50% off\n)\n</code></pre>"},{"location":"guide/expressions/#use-with-increment","title":"Use with increment()","text":"<p>Shortcut for common increment pattern:</p> <pre><code># These are equivalent:\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\nawait Post.objects.filter(id=1).increment(\"views\", by=1)\n\n# Decrement\nawait Post.objects.filter(id=1).increment(\"views\", by=-1)\n</code></pre>"},{"location":"guide/expressions/#bulk-updates","title":"Bulk Updates","text":"<p>F expressions work with bulk updates:</p> <pre><code># Give everyone a 5% raise\nawait Employee.objects.update(salary=F(\"salary\") * 1.05)\n\n# Reset all counters\nawait Stats.objects.update(count=F(\"count\") * 0)  # Set to 0\n</code></pre>"},{"location":"guide/expressions/#complex-expressions","title":"Complex Expressions","text":"<p>Chain operations:</p> <pre><code># (price * quantity) - discount\nawait Order.objects.filter(id=1).update(\n    total=F(\"price\") * F(\"quantity\") - F(\"discount\")\n)\n\n# Nested: ((base + bonus) * multiplier)\nawait Score.objects.filter(id=1).update(\n    final=((F(\"base\") + F(\"bonus\")) * F(\"multiplier\"))\n)\n</code></pre>"},{"location":"guide/expressions/#with-value-constants","title":"With Value Constants","text":"<p>Mix F expressions with constants:</p> <pre><code># Add flat fee\nawait Order.objects.filter(id=1).update(total=F(\"subtotal\") + 9.99)\n\n# Apply tax rate\nawait Order.objects.filter(id=1).update(total=F(\"subtotal\") * 1.08)\n</code></pre>"},{"location":"guide/expressions/#reverse-operations","title":"Reverse Operations","text":"<p>F expressions support reverse operations:</p> <pre><code># 100 - balance (instead of balance - 100)\nawait Account.objects.filter(id=1).update(remaining=100 - F(\"spent\"))\n\n# 2 * multiplier\nawait Score.objects.filter(id=1).update(doubled=2 * F(\"base\"))\n</code></pre>"},{"location":"guide/expressions/#examples","title":"Examples","text":""},{"location":"guide/expressions/#page-view-counter","title":"Page View Counter","text":"<pre><code>async def view_post(post_id: int):\n    await Post.objects.filter(id=post_id).increment(\"views\")\n</code></pre>"},{"location":"guide/expressions/#inventory-management","title":"Inventory Management","text":"<pre><code>async def purchase(product_id: int, quantity: int):\n    await Product.objects.filter(id=product_id).update(\n        stock=F(\"stock\") - quantity\n    )\n\nasync def restock(product_id: int, quantity: int):\n    await Product.objects.filter(id=product_id).update(\n        stock=F(\"stock\") + quantity\n    )\n</code></pre>"},{"location":"guide/expressions/#balance-transfer","title":"Balance Transfer","text":"<pre><code>from oxyde.db import transaction\n\nasync def transfer(from_id: int, to_id: int, amount: float):\n    async with transaction.atomic():\n        await Account.objects.filter(id=from_id).update(\n            balance=F(\"balance\") - amount\n        )\n        await Account.objects.filter(id=to_id).update(\n            balance=F(\"balance\") + amount\n        )\n</code></pre>"},{"location":"guide/expressions/#pricing-rules","title":"Pricing Rules","text":"<pre><code># Apply 20% discount to all sale items\nawait Product.objects.filter(on_sale=True).update(\n    price=F(\"price\") * 0.8\n)\n\n# Round up to nearest dollar\nawait Product.objects.update(\n    price=F(\"price\") + 0.99  # Simple approach\n)\n</code></pre>"},{"location":"guide/expressions/#score-calculation","title":"Score Calculation","text":"<pre><code># Calculate weighted score\nawait Score.objects.update(\n    total=F(\"correct\") * 10 - F(\"wrong\") * 5\n)\n</code></pre>"},{"location":"guide/expressions/#limitations","title":"Limitations","text":""},{"location":"guide/expressions/#no-filtering-with-f","title":"No Filtering with F","text":"<p>F expressions are for UPDATE values, not for filtering:</p> <pre><code># This won't work\n# await User.objects.filter(balance__gt=F(\"credit_limit\")).all()\n\n# Use raw SQL or application logic instead\n</code></pre>"},{"location":"guide/expressions/#no-string-operations","title":"No String Operations","text":"<p>F expressions only support numeric operations:</p> <pre><code># These won't work:\n# F(\"first_name\") + \" \" + F(\"last_name\")  # String concat\n# F(\"name\").lower()  # String methods\n\n# Use database functions or compute in application\n</code></pre>"},{"location":"guide/expressions/#read-only-in-select","title":"Read-Only in Select","text":"<p>F expressions are primarily for UPDATE statements. For computed columns in SELECT, use annotations with aggregate functions.</p>"},{"location":"guide/expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Aggregation \u2014 Aggregate functions and GROUP BY</li> <li>Queries \u2014 Full query reference</li> <li>Transactions \u2014 Atomic operations with transactions</li> </ul>"},{"location":"guide/fields/","title":"Fields","text":"<p>The <code>Field()</code> function configures both Pydantic validation and database schema.</p>"},{"location":"guide/fields/#basic-usage","title":"Basic Usage","text":"<pre><code>from oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str = Field(max_length=100)\n    email: str = Field(db_unique=True, db_index=True)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/fields/#field-parameters","title":"Field() Parameters","text":""},{"location":"guide/fields/#database-parameters","title":"Database Parameters","text":"Parameter Type Default Description <code>db_pk</code> <code>bool</code> <code>False</code> Primary key <code>db_index</code> <code>bool</code> <code>False</code> Create index <code>db_index_name</code> <code>str</code> Auto Custom index name <code>db_index_method</code> <code>str</code> <code>\"btree\"</code> Index method: btree, hash, gin, gist <code>db_unique</code> <code>bool</code> <code>False</code> UNIQUE constraint <code>db_nullable</code> <code>bool</code> None Override NULL/NOT NULL (None = infer from type) <code>db_column</code> <code>str</code> Field name Database column name <code>db_type</code> <code>str</code> Auto SQL type override <code>db_default</code> <code>str</code> None SQL DEFAULT expression <code>db_comment</code> <code>str</code> None Column comment"},{"location":"guide/fields/#foreign-key-parameters","title":"Foreign Key Parameters","text":"Parameter Type Default Description <code>db_fk</code> <code>str</code> PK of related model Target field for FK <code>db_on_delete</code> <code>str</code> <code>\"RESTRICT\"</code> ON DELETE action <code>db_on_update</code> <code>str</code> <code>\"CASCADE\"</code> ON UPDATE action"},{"location":"guide/fields/#relation-parameters","title":"Relation Parameters","text":"Parameter Type Default Description <code>db_reverse_fk</code> <code>str</code> None Reverse FK field name <code>db_m2m</code> <code>bool</code> <code>False</code> Many-to-many relation <code>db_through</code> <code>str</code> None M2M junction table"},{"location":"guide/fields/#pydantic-parameters","title":"Pydantic Parameters","text":"<p>All standard Pydantic <code>Field()</code> parameters work:</p> Parameter Type Description <code>default</code> Any Default value <code>default_factory</code> Callable Factory for default value <code>alias</code> <code>str</code> JSON key name <code>description</code> <code>str</code> Field description <code>ge</code>, <code>gt</code>, <code>le</code>, <code>lt</code> Number Numeric bounds <code>min_length</code>, <code>max_length</code> <code>int</code> String length bounds <code>pattern</code> <code>str</code> Regex pattern"},{"location":"guide/fields/#primary-key","title":"Primary Key","text":"<pre><code># Auto-increment integer\nid: int | None = Field(default=None, db_pk=True)\n\n# UUID\nfrom uuid import UUID, uuid4\nid: UUID = Field(default_factory=uuid4, db_pk=True)\n\n# Custom type\nid: int = Field(db_pk=True, db_type=\"BIGSERIAL\")\n</code></pre>"},{"location":"guide/fields/#indexes","title":"Indexes","text":"<pre><code># Simple index\nemail: str = Field(db_index=True)\n\n# Unique index\nusername: str = Field(db_unique=True)\n\n# Custom index name\nemail: str = Field(db_index=True, db_index_name=\"ix_users_email\")\n\n# Index method (PostgreSQL)\ndata: dict = Field(db_type=\"JSONB\", db_index=True, db_index_method=\"gin\")\n</code></pre>"},{"location":"guide/fields/#sql-defaults","title":"SQL Defaults","text":"<pre><code># Timestamp\ncreated_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n# PostgreSQL functions\nuuid: str = Field(db_default=\"gen_random_uuid()\")\n\n# String literal (note the quotes)\nstatus: str = Field(db_default=\"'pending'\")\n\n# Numeric\ncount: int = Field(db_default=\"0\")\n</code></pre> <p>Python vs SQL Default</p> <p><code>default</code> is used when creating Python objects. <code>db_default</code> is used by the database when inserting rows.</p>"},{"location":"guide/fields/#column-mapping","title":"Column Mapping","text":"<pre><code># Different Python name and DB column\ncreated_at: datetime = Field(db_column=\"created_timestamp\")\n\n# With JSON alias too\ncreated_at: datetime = Field(\n    alias=\"createdAt\",           # JSON API uses camelCase\n    db_column=\"created_timestamp\" # DB uses snake_case\n)\n</code></pre>"},{"location":"guide/fields/#custom-sql-types","title":"Custom SQL Types","text":"<pre><code># Override inferred type\nname: str = Field(db_type=\"VARCHAR(255)\")\n\n# PostgreSQL-specific\ndata: dict = Field(db_type=\"JSONB\")\ntags: list[str] = Field(db_type=\"TEXT[]\")\n\n# MySQL-specific\ncontent: str = Field(db_type=\"LONGTEXT\")\n</code></pre>"},{"location":"guide/fields/#foreign-keys","title":"Foreign Keys","text":"<p>Foreign keys are defined by type annotation:</p> <pre><code>class Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")  # FK to Author\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/fields/#fk-to-non-pk-field","title":"FK to Non-PK Field","text":"<pre><code># FK to Author.uuid instead of Author.id\nauthor: \"Author\" | None = Field(\n    default=None,\n    db_fk=\"uuid\",  # Target the uuid field\n    db_on_delete=\"CASCADE\"\n)\n# Creates author_uuid column\n</code></pre>"},{"location":"guide/fields/#on-delete-actions","title":"ON DELETE Actions","text":"Action Description <code>CASCADE</code> Delete related rows <code>SET NULL</code> Set FK to NULL (requires nullable field) <code>RESTRICT</code> Prevent deletion if references exist <code>NO ACTION</code> Same as RESTRICT (deferred) <pre><code># CASCADE - delete posts when author is deleted\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n# SET NULL - set author_id to NULL when author is deleted\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"SET NULL\")\n\n# RESTRICT - prevent author deletion if posts exist\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"RESTRICT\")\n</code></pre>"},{"location":"guide/fields/#relations","title":"Relations","text":""},{"location":"guide/fields/#reverse-foreign-key","title":"Reverse Foreign Key","text":"<p>Define on the \"one\" side of a one-to-many relationship:</p> <pre><code>class Author(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    posts: list[\"Post\"] = Field(db_reverse_fk=\"author\")  # Virtual field - not stored in DB\n\n    class Meta:\n        is_table = True\n</code></pre> <p>Use with <code>prefetch()</code>:</p> <pre><code>authors = await Author.objects.prefetch(\"posts\").all()\nfor author in authors:\n    print(f\"{author.name} has {len(author.posts)} posts\")\n</code></pre>"},{"location":"guide/fields/#many-to-many","title":"Many-to-Many","text":"<pre><code>class Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    tags: list[\"Tag\"] = Field(db_m2m=True, db_through=\"PostTag\")\n\n    class Meta:\n        is_table = True\n\n\nclass Tag(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str = Field(db_unique=True)\n\n    class Meta:\n        is_table = True\n\n\nclass PostTag(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    post: \"Post\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n    tag: \"Tag\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/fields/#pydantic-validation","title":"Pydantic Validation","text":""},{"location":"guide/fields/#numeric-bounds","title":"Numeric Bounds","text":"<pre><code>age: int = Field(ge=0, le=150)      # 0 &lt;= age &lt;= 150\nprice: float = Field(gt=0)          # price &gt; 0\nquantity: int = Field(ge=1, le=100) # 1 &lt;= quantity &lt;= 100\n</code></pre>"},{"location":"guide/fields/#string-validation","title":"String Validation","text":"<pre><code>name: str = Field(min_length=1, max_length=100)\nemail: str = Field(pattern=r\"^[\\w.-]+@[\\w.-]+\\.\\w+$\")\n</code></pre>"},{"location":"guide/fields/#required-vs-optional","title":"Required vs Optional","text":"<pre><code># Required - no default\nname: str\n\n# Optional with None default\nbio: str | None = Field(default=None)\n\n# Optional with value default\nstatus: str = Field(default=\"active\")\n\n# Required but can be None\ndata: str | None  # Must be passed, but can be None\n</code></pre>"},{"location":"guide/fields/#comments","title":"Comments","text":"<p>Add SQL comments to columns:</p> <pre><code>email: str = Field(\n    db_unique=True,\n    db_comment=\"Primary email address for notifications\"\n)\n</code></pre>"},{"location":"guide/fields/#complete-example","title":"Complete Example","text":"<pre><code>from datetime import datetime\nfrom decimal import Decimal\nfrom uuid import UUID, uuid4\nfrom oxyde import Model, Field\n\nclass Product(Model):\n    # Primary key\n    id: UUID = Field(default_factory=uuid4, db_pk=True)\n\n    # Required fields\n    name: str = Field(min_length=1, max_length=200)\n    price: Decimal = Field(ge=0, db_type=\"NUMERIC(10, 2)\")\n\n    # Optional fields\n    description: str | None = Field(default=None)\n    sku: str | None = Field(default=None, db_unique=True, db_index=True)\n\n    # With defaults\n    active: bool = Field(default=True)\n    stock: int = Field(default=0, ge=0)\n\n    # SQL defaults\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n    updated_at: datetime | None = Field(default=None)\n\n    # Foreign key\n    category: \"Category\" | None = Field(default=None, db_on_delete=\"SET NULL\")\n\n    class Meta:\n        is_table = True\n        table_name = \"products\"\n</code></pre>"},{"location":"guide/fields/#next-steps","title":"Next Steps","text":"<ul> <li>Queries \u2014 Query your models</li> <li>Filtering \u2014 Filter expressions</li> <li>Relations \u2014 Foreign keys and joins</li> </ul>"},{"location":"guide/filtering/","title":"Filtering","text":"<p>Oxyde supports Django-style field lookups for filtering queries.</p>"},{"location":"guide/filtering/#basic-filtering","title":"Basic Filtering","text":"<pre><code># Exact match (default)\nusers = await User.objects.filter(status=\"active\").all()\n\n# Multiple conditions (AND)\nusers = await User.objects.filter(status=\"active\", age__gte=18).all()\n</code></pre>"},{"location":"guide/filtering/#lookup-syntax","title":"Lookup Syntax","text":"<p>Lookups use double underscore notation: <code>field__lookup=value</code></p> <pre><code>filter(age__gte=18)      # age &gt;= 18\nfilter(name__contains=\"john\")  # name LIKE '%john%'\n</code></pre> <p>If no lookup is specified, <code>exact</code> is used:</p> <pre><code>filter(status=\"active\")        # status = 'active'\nfilter(status__exact=\"active\") # same\n</code></pre>"},{"location":"guide/filtering/#comparison-lookups","title":"Comparison Lookups","text":"Lookup SQL Example <code>exact</code> <code>=</code> <code>filter(age=18)</code> <code>gt</code> <code>&gt;</code> <code>filter(age__gt=18)</code> <code>gte</code> <code>&gt;=</code> <code>filter(age__gte=18)</code> <code>lt</code> <code>&lt;</code> <code>filter(age__lt=65)</code> <code>lte</code> <code>&lt;=</code> <code>filter(age__lte=65)</code> <pre><code># Age between 18 and 65 (inclusive)\nusers = await User.objects.filter(age__gte=18, age__lte=65).all()\n</code></pre>"},{"location":"guide/filtering/#range-lookups","title":"Range Lookups","text":""},{"location":"guide/filtering/#between","title":"between","text":"<pre><code># BETWEEN 18 AND 65\nusers = await User.objects.filter(age__between=[18, 65]).all()\n</code></pre>"},{"location":"guide/filtering/#range","title":"range","text":"<p>Alias for <code>between</code>:</p> <pre><code>users = await User.objects.filter(age__range=[18, 65]).all()\n</code></pre>"},{"location":"guide/filtering/#string-lookups","title":"String Lookups","text":"Lookup SQL Case Sensitive <code>contains</code> <code>LIKE '%...%'</code> Yes <code>icontains</code> <code>ILIKE '%...%'</code> No <code>startswith</code> <code>LIKE '...%'</code> Yes <code>istartswith</code> <code>ILIKE '...%'</code> No <code>endswith</code> <code>LIKE '%...'</code> Yes <code>iendswith</code> <code>ILIKE '%...'</code> No <code>iexact</code> <code>LOWER(...) = LOWER(...)</code> No <pre><code># Contains (case-sensitive)\nusers = await User.objects.filter(name__contains=\"john\").all()\n\n# Contains (case-insensitive)\nusers = await User.objects.filter(name__icontains=\"john\").all()\n\n# Starts with\nusers = await User.objects.filter(email__startswith=\"admin@\").all()\n\n# Ends with\nusers = await User.objects.filter(email__endswith=\"@example.com\").all()\n\n# Exact (case-insensitive)\nusers = await User.objects.filter(email__iexact=\"JOHN@EXAMPLE.COM\").all()\n</code></pre>"},{"location":"guide/filtering/#null-checks","title":"NULL Checks","text":""},{"location":"guide/filtering/#isnull","title":"isnull","text":"<pre><code># IS NULL\nusers = await User.objects.filter(deleted_at__isnull=True).all()\n\n# IS NOT NULL\nusers = await User.objects.filter(deleted_at__isnull=False).all()\n</code></pre>"},{"location":"guide/filtering/#in-lookup","title":"IN Lookup","text":"<pre><code># IN clause\nusers = await User.objects.filter(status__in=[\"active\", \"pending\"]).all()\n\n# With subquery (manual)\nadmin_ids = await User.objects.filter(role=\"admin\").values_list(\"id\", flat=True).all()\nposts = await Post.objects.filter(author_id__in=admin_ids).all()\n</code></pre>"},{"location":"guide/filtering/#date-lookups","title":"Date Lookups","text":""},{"location":"guide/filtering/#year-month-day","title":"year / month / day","text":"<p>Extract date parts:</p> <pre><code># Posts from 2024\nposts = await Post.objects.filter(created_at__year=2024).all()\n\n# Posts from December 2024\nposts = await Post.objects.filter(created_at__month=(2024, 12)).all()\n\n# Posts from December 25, 2024\nposts = await Post.objects.filter(created_at__day=(2024, 12, 25)).all()\n</code></pre>"},{"location":"guide/filtering/#q-expressions","title":"Q Expressions","text":"<p>For complex boolean logic (OR, NOT):</p> <pre><code>from oxyde import Q\n\n# OR\nusers = await User.objects.filter(\n    Q(role=\"admin\") | Q(role=\"moderator\")\n).all()\n\n# NOT\nusers = await User.objects.filter(~Q(status=\"banned\")).all()\n\n# Complex\nusers = await User.objects.filter(\n    Q(age__gte=18) &amp; (Q(status=\"active\") | Q(status=\"premium\"))\n).all()\n</code></pre>"},{"location":"guide/filtering/#combining-q-objects","title":"Combining Q Objects","text":"Operator Meaning <code>&amp;</code> AND <code>\\|</code> OR <code>~</code> NOT <pre><code># (age &gt;= 18 AND status = 'active') OR role = 'admin'\nusers = await User.objects.filter(\n    (Q(age__gte=18) &amp; Q(status=\"active\")) | Q(role=\"admin\")\n).all()\n\n# NOT (status = 'banned' OR status = 'suspended')\nusers = await User.objects.filter(\n    ~(Q(status=\"banned\") | Q(status=\"suspended\"))\n).all()\n</code></pre>"},{"location":"guide/filtering/#mixing-q-and-kwargs","title":"Mixing Q and kwargs","text":"<pre><code># Q expressions with keyword arguments\nusers = await User.objects.filter(\n    Q(role=\"admin\") | Q(role=\"moderator\"),\n    status=\"active\"  # AND with the Q expression\n).all()\n</code></pre>"},{"location":"guide/filtering/#exclude","title":"exclude()","text":"<p>Negate conditions:</p> <pre><code># NOT status = 'banned'\nusers = await User.objects.exclude(status=\"banned\").all()\n\n# Equivalent to\nusers = await User.objects.filter(~Q(status=\"banned\")).all()\n</code></pre> <p>Chain with filter:</p> <pre><code># status = 'active' AND NOT role = 'bot'\nusers = await User.objects.filter(status=\"active\").exclude(role=\"bot\").all()\n</code></pre>"},{"location":"guide/filtering/#lookup-reference-by-type","title":"Lookup Reference by Type","text":""},{"location":"guide/filtering/#string-fields","title":"String Fields","text":"<ul> <li><code>exact</code>, <code>iexact</code></li> <li><code>contains</code>, <code>icontains</code></li> <li><code>startswith</code>, <code>istartswith</code></li> <li><code>endswith</code>, <code>iendswith</code></li> <li><code>in</code>, <code>isnull</code></li> </ul>"},{"location":"guide/filtering/#numeric-fields-int-float-decimal","title":"Numeric Fields (int, float, Decimal)","text":"<ul> <li><code>exact</code></li> <li><code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code></li> <li><code>between</code>, <code>range</code></li> <li><code>in</code>, <code>isnull</code></li> </ul>"},{"location":"guide/filtering/#datetimedate-fields","title":"DateTime/Date Fields","text":"<ul> <li><code>exact</code></li> <li><code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code></li> <li><code>between</code>, <code>range</code></li> <li><code>year</code>, <code>month</code>, <code>day</code></li> <li><code>in</code>, <code>isnull</code></li> </ul>"},{"location":"guide/filtering/#boolean-fields","title":"Boolean Fields","text":"<ul> <li><code>exact</code></li> <li><code>in</code>, <code>isnull</code></li> </ul>"},{"location":"guide/filtering/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/filtering/#pagination","title":"Pagination","text":"<pre><code>page = 2\nper_page = 20\nusers = await User.objects.filter(\n    status=\"active\"\n).order_by(\"-created_at\").offset((page - 1) * per_page).limit(per_page).all()\n</code></pre>"},{"location":"guide/filtering/#search","title":"Search","text":"<pre><code>query = \"john\"\nusers = await User.objects.filter(\n    Q(name__icontains=query) | Q(email__icontains=query)\n).all()\n</code></pre>"},{"location":"guide/filtering/#date-range","title":"Date Range","text":"<pre><code>from datetime import datetime, timedelta\n\nnow = datetime.utcnow()\nlast_week = now - timedelta(days=7)\n\nrecent = await Post.objects.filter(\n    created_at__gte=last_week,\n    created_at__lt=now\n).all()\n</code></pre>"},{"location":"guide/filtering/#activesoft-delete","title":"Active/Soft Delete","text":"<pre><code># Active records only\nactive = await User.objects.filter(deleted_at__isnull=True).all()\n\n# Include deleted\nall_users = await User.objects.all()\n</code></pre>"},{"location":"guide/filtering/#related-field-lookups-fk-traversal","title":"Related Field Lookups (FK Traversal)","text":"<p>Oxyde supports Django-style filtering through foreign key relationships:</p> <pre><code># Filter posts by author's age (auto-joins author table)\nposts = await Post.objects.filter(author__age__gte=18).all()\n\n# Filter by nested FK\nposts = await Post.objects.filter(author__company__name=\"Acme\").all()\n\n# Combine with Q expressions\nposts = await Post.objects.filter(\n    Q(author__age__gte=18) | Q(author__role=\"admin\")\n).all()\n</code></pre> <p>This automatically adds the necessary JOINs to the query.</p>"},{"location":"guide/filtering/#known-limitations","title":"Known Limitations","text":""},{"location":"guide/filtering/#ambiguous-columns-with-join","title":"Ambiguous Columns with JOIN","text":"<p>When using <code>join()</code>, filter on FK column to avoid ambiguity:</p> <pre><code># May be ambiguous if both tables have 'id'\nposts = await Post.objects.join(\"author\").filter(id__in=[1,2,3]).all()\n\n# Better: filter before join or use FK column\nposts = await Post.objects.filter(id__in=[1,2,3]).join(\"author\").all()\n</code></pre>"},{"location":"guide/filtering/#next-steps","title":"Next Steps","text":"<ul> <li>Expressions \u2014 F expressions for database operations</li> <li>Aggregation \u2014 GROUP BY and aggregate functions</li> <li>Queries \u2014 Full query reference</li> </ul>"},{"location":"guide/migrations/","title":"Migrations","text":"<p>Oxyde provides Django-style migrations for schema management.</p>"},{"location":"guide/migrations/#overview","title":"Overview","text":"<p>Migrations track database schema changes:</p> <ol> <li>Define models in Python</li> <li>Run <code>oxyde makemigrations</code> to generate migration files</li> <li>Run <code>oxyde migrate</code> to apply changes to the database</li> </ol>"},{"location":"guide/migrations/#cli-commands","title":"CLI Commands","text":""},{"location":"guide/migrations/#makemigrations","title":"makemigrations","text":"<p>Generate migration files from model changes:</p> <pre><code># Generate migrations\noxyde makemigrations\n\n# With custom name\noxyde makemigrations --name \"add_user_profile\"\n\n# Dry run (show without creating)\noxyde makemigrations --dry-run\n</code></pre> <p>Configuration (migrations directory, dialect) is set in <code>oxyde_config.py</code>.</p>"},{"location":"guide/migrations/#migrate","title":"migrate","text":"<p>Apply pending migrations:</p> <pre><code># Apply all pending\noxyde migrate\n\n# Target specific migration\noxyde migrate 0003_add_posts\n\n# Migrate to \"zero\" (rollback all)\noxyde migrate zero\n\n# Mark as applied without running (fake)\noxyde migrate 0003_add_posts --fake\n\n# Use specific database alias\noxyde migrate --db-alias analytics\n</code></pre>"},{"location":"guide/migrations/#showmigrations","title":"showmigrations","text":"<p>List migration status:</p> <pre><code>oxyde showmigrations\n\n# Use specific database alias\noxyde showmigrations --db-alias analytics\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udccb Migrations status:\n\n  [\u2713] 0001_initial\n  [\u2713] 0002_add_profile\n  [ ] 0003_add_tags\n\nTotal: 3 migration(s)\nApplied: 2\nPending: 1\n</code></pre>"},{"location":"guide/migrations/#sqlmigrate","title":"sqlmigrate","text":"<p>Show SQL for a migration without running it:</p> <pre><code>oxyde sqlmigrate 0001_initial\n</code></pre>"},{"location":"guide/migrations/#migration-files","title":"Migration Files","text":"<p>Migrations are Python files in the <code>migrations/</code> directory:</p> <pre><code>migrations/\n\u251c\u2500\u2500 0001_initial.py\n\u251c\u2500\u2500 0002_add_profile.py\n\u2514\u2500\u2500 0003_add_tags.py\n</code></pre>"},{"location":"guide/migrations/#migration-structure","title":"Migration Structure","text":"<pre><code># 0001_initial.py\n\"\"\"Auto-generated migration.\n\nCreated: 2024-01-15 10:30:00\n\"\"\"\n\ndepends_on = None\n\n\ndef upgrade(ctx):\n    \"\"\"Apply migration.\"\"\"\n    ctx.create_table(\n        \"users\",\n        fields=[\n            {\"name\": \"id\", \"field_type\": \"INTEGER\", \"primary_key\": True},\n            {\"name\": \"name\", \"field_type\": \"TEXT\", \"nullable\": False},\n            {\"name\": \"email\", \"field_type\": \"TEXT\", \"unique\": True},\n        ],\n        indexes=[\n            {\"name\": \"ix_users_email\", \"columns\": [\"email\"]},\n        ],\n    )\n\n\ndef downgrade(ctx):\n    \"\"\"Revert migration.\"\"\"\n    ctx.drop_table(\"users\")\n</code></pre>"},{"location":"guide/migrations/#supported-operations","title":"Supported Operations","text":"<p>All operations are called on the <code>ctx</code> (MigrationContext) object passed to <code>upgrade()</code> and <code>downgrade()</code>.</p>"},{"location":"guide/migrations/#create-table","title":"Create Table","text":"<pre><code>ctx.create_table(\n    \"users\",\n    fields=[\n        {\"name\": \"id\", \"field_type\": \"INTEGER\", \"primary_key\": True},\n        {\"name\": \"name\", \"field_type\": \"TEXT\", \"nullable\": False},\n        {\"name\": \"email\", \"field_type\": \"TEXT\", \"unique\": True},\n    ],\n    indexes=[\n        {\"name\": \"ix_users_email\", \"columns\": [\"email\"]},\n    ],\n)\n</code></pre>"},{"location":"guide/migrations/#drop-table","title":"Drop Table","text":"<pre><code>ctx.drop_table(\"old_users\")\n</code></pre>"},{"location":"guide/migrations/#rename-table","title":"Rename Table","text":"<pre><code>ctx.rename_table(\"old_name\", \"new_name\")\n</code></pre>"},{"location":"guide/migrations/#add-column","title":"Add Column","text":"<pre><code>ctx.add_column(\"users\", {\n    \"name\": \"age\",\n    \"field_type\": \"INTEGER\",\n    \"nullable\": True,\n})\n</code></pre>"},{"location":"guide/migrations/#drop-column","title":"Drop Column","text":"<pre><code>ctx.drop_column(\"users\", \"old_field\")\n</code></pre>"},{"location":"guide/migrations/#rename-column","title":"Rename Column","text":"<pre><code>ctx.rename_column(\"users\", \"old_name\", \"new_name\")\n</code></pre>"},{"location":"guide/migrations/#alter-column","title":"Alter Column","text":"<pre><code>ctx.alter_column(\"users\", \"name\", nullable=False, type=\"VARCHAR(255)\")\n</code></pre>"},{"location":"guide/migrations/#create-index","title":"Create Index","text":"<pre><code>ctx.create_index(\"users\", {\n    \"name\": \"ix_users_email\",\n    \"columns\": [\"email\"],\n    \"unique\": True,\n})\n</code></pre>"},{"location":"guide/migrations/#drop-index","title":"Drop Index","text":"<pre><code>ctx.drop_index(\"users\", \"ix_users_old\")\n</code></pre>"},{"location":"guide/migrations/#add-foreign-key","title":"Add Foreign Key","text":"<pre><code>ctx.add_foreign_key(\n    \"posts\",\n    \"fk_posts_author\",\n    [\"author_id\"],\n    \"users\",\n    [\"id\"],\n    on_delete=\"CASCADE\",\n    on_update=\"NO ACTION\",\n)\n</code></pre>"},{"location":"guide/migrations/#drop-foreign-key","title":"Drop Foreign Key","text":"<pre><code>ctx.drop_foreign_key(\"posts\", \"fk_posts_author\")\n</code></pre>"},{"location":"guide/migrations/#add-check-constraint","title":"Add Check Constraint","text":"<pre><code>ctx.add_check(\"users\", \"chk_age_positive\", \"age &gt;= 0\")\n</code></pre>"},{"location":"guide/migrations/#drop-check-constraint","title":"Drop Check Constraint","text":"<pre><code>ctx.drop_check(\"users\", \"chk_age_positive\")\n</code></pre>"},{"location":"guide/migrations/#execute-raw-sql","title":"Execute Raw SQL","text":"<p>For data migrations or unsupported operations:</p> <pre><code>ctx.execute(\"UPDATE users SET status = 'active' WHERE status IS NULL\")\n</code></pre> <p>Raw SQL</p> <p><code>ctx.execute()</code> runs arbitrary SQL. Use carefully and ensure it's compatible with your target database.</p>"},{"location":"guide/migrations/#workflow-example","title":"Workflow Example","text":""},{"location":"guide/migrations/#1-define-initial-models","title":"1. Define Initial Models","text":"<pre><code># models.py\nfrom oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/migrations/#2-generate-initial-migration","title":"2. Generate Initial Migration","text":"<pre><code>oxyde makemigrations --name \"initial\"\n</code></pre> <p>Creates <code>migrations/0001_initial.py</code>.</p>"},{"location":"guide/migrations/#3-apply-migration","title":"3. Apply Migration","text":"<pre><code>oxyde migrate\n</code></pre>"},{"location":"guide/migrations/#4-add-new-field","title":"4. Add New Field","text":"<pre><code>class User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n    age: int | None = Field(default=None)  # New field\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/migrations/#5-generate-migration-for-change","title":"5. Generate Migration for Change","text":"<pre><code>oxyde makemigrations --name \"add_age\"\n</code></pre> <p>Creates <code>migrations/0002_add_age.py</code>.</p>"},{"location":"guide/migrations/#6-apply-new-migration","title":"6. Apply New Migration","text":"<pre><code>oxyde migrate\n</code></pre>"},{"location":"guide/migrations/#database-specific-considerations","title":"Database-Specific Considerations","text":""},{"location":"guide/migrations/#postgresql","title":"PostgreSQL","text":"<ul> <li>Full ALTER TABLE support</li> <li>Transactional DDL</li> <li>Concurrent index creation</li> </ul>"},{"location":"guide/migrations/#sqlite","title":"SQLite","text":"<ul> <li>Limited ALTER TABLE (add column only)</li> <li>Table recreation for complex changes</li> <li>No transactional DDL</li> </ul>"},{"location":"guide/migrations/#mysql","title":"MySQL","text":"<ul> <li>ALTER TABLE with some limitations</li> <li>No transactional DDL</li> <li>Column changes may require data copy</li> </ul>"},{"location":"guide/migrations/#migration-dependencies","title":"Migration Dependencies","text":"<p>Dependencies are specified via <code>depends_on</code> at the top of the file:</p> <pre><code># 0003_add_posts.py\n\"\"\"Auto-generated migration.\n\nCreated: 2024-01-15 11:00:00\n\"\"\"\n\ndepends_on = \"0002_add_age\"\n\n\ndef upgrade(ctx):\n    \"\"\"Apply migration.\"\"\"\n    ctx.create_table(\n        \"posts\",\n        fields=[\n            {\"name\": \"id\", \"field_type\": \"INTEGER\", \"primary_key\": True},\n            {\"name\": \"title\", \"field_type\": \"TEXT\", \"nullable\": False},\n            {\"name\": \"author_id\", \"field_type\": \"INTEGER\", \"nullable\": False},\n        ],\n    )\n    ctx.add_foreign_key(\n        \"posts\",\n        \"fk_posts_author\",\n        [\"author_id\"],\n        \"users\",\n        [\"id\"],\n        on_delete=\"CASCADE\",\n    )\n\n\ndef downgrade(ctx):\n    \"\"\"Revert migration.\"\"\"\n    ctx.drop_foreign_key(\"posts\", \"fk_posts_author\")\n    ctx.drop_table(\"posts\")\n</code></pre>"},{"location":"guide/migrations/#best-practices","title":"Best Practices","text":""},{"location":"guide/migrations/#1-review-generated-migrations","title":"1. Review Generated Migrations","text":"<p>Always review generated SQL before applying:</p> <pre><code>oxyde sqlmigrate 0002_add_profile\n</code></pre>"},{"location":"guide/migrations/#2-test-on-development-first","title":"2. Test on Development First","text":"<pre><code># Development\noxyde migrate\n\n# Production (after testing)\noxyde migrate --db-alias production\n</code></pre>"},{"location":"guide/migrations/#3-one-change-per-migration","title":"3. One Change Per Migration","text":"<pre><code># Good\noxyde makemigrations --name \"add_user_age\"\noxyde makemigrations --name \"add_user_bio\"\n\n# Avoid: multiple unrelated changes\noxyde makemigrations --name \"various_changes\"\n</code></pre>"},{"location":"guide/migrations/#4-dont-edit-applied-migrations","title":"4. Don't Edit Applied Migrations","text":"<p>Once a migration is applied to production, create new migrations for fixes.</p>"},{"location":"guide/migrations/#5-keep-migrations-in-version-control","title":"5. Keep Migrations in Version Control","text":"<p>Commit migration files alongside model changes.</p>"},{"location":"guide/migrations/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/migrations/#migration-not-detected","title":"Migration Not Detected","text":"<p>Ensure models are imported before running <code>makemigrations</code>:</p> <pre><code># In your app's __init__.py\nfrom .models import User, Post, ...\n</code></pre>"},{"location":"guide/migrations/#schema-mismatch","title":"Schema Mismatch","text":"<p>If the database is out of sync:</p> <pre><code># Show current state\noxyde showmigrations\n\n# Fake migration (mark as applied without running)\noxyde migrate 0002_add_profile --fake\n</code></pre>"},{"location":"guide/migrations/#rollback-failed-migration","title":"Rollback Failed Migration","text":"<pre><code># Rollback to specific version\noxyde migrate 0001_initial\n\n# Rollback all migrations\noxyde migrate zero\n</code></pre>"},{"location":"guide/migrations/#complete-example","title":"Complete Example","text":"<pre><code># models.py\nfrom datetime import datetime\nfrom oxyde import Model, Field, Index\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    email: str = Field(db_unique=True)\n    name: str\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n    class Meta:\n        is_table = True\n        table_name = \"users\"\n\n\nclass Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    content: str\n    author: \"User\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n    class Meta:\n        is_table = True\n        table_name = \"posts\"\n        indexes = [\n            Index((\"author_id\", \"created_at\")),\n        ]\n</code></pre> <pre><code># Generate and apply\noxyde makemigrations --name initial\noxyde migrate\n\n# Check status\noxyde showmigrations\n#   [\u2713] 0001_initial\n</code></pre>"},{"location":"guide/migrations/#next-steps","title":"Next Steps","text":"<ul> <li>Models \u2014 Model definition</li> <li>Fields \u2014 Field options</li> <li>Connections \u2014 Database connections</li> </ul>"},{"location":"guide/models/","title":"Models","text":"<p>Models are the foundation of Oxyde. Each model class represents a database table, with class attributes defining columns.</p>"},{"location":"guide/models/#basic-model-definition","title":"Basic Model Definition","text":"<pre><code>from oxyde import Model, Field\n\nclass User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str = Field(db_unique=True)\n    age: int | None = Field(default=None)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#the-meta-class","title":"The Meta Class","text":"<p>The inner <code>Meta</code> class configures table-level settings:</p> <pre><code>class User(Model):\n    class Meta:\n        is_table = True              # Required: marks this as a database table\n        table_name = \"users\"         # Optional: custom table name (default: class name)\n        schema = \"public\"            # Optional: database schema\n</code></pre>"},{"location":"guide/models/#required-settings","title":"Required Settings","text":"Setting Type Description <code>is_table</code> <code>bool</code> Must be <code>True</code> for database tables"},{"location":"guide/models/#optional-settings","title":"Optional Settings","text":"Setting Type Default Description <code>table_name</code> <code>str</code> Class name Database table name <code>schema</code> <code>str</code> None Database schema <code>indexes</code> <code>list[Index]</code> <code>[]</code> Composite indexes <code>constraints</code> <code>list[Check]</code> <code>[]</code> CHECK constraints <code>unique_together</code> <code>list[tuple]</code> <code>[]</code> Composite unique constraints <code>primary_key</code> <code>tuple[str, ...]</code> None Composite primary key"},{"location":"guide/models/#type-annotations","title":"Type Annotations","text":"<p>Oxyde uses Python type hints to infer SQL types:</p> <pre><code>class Example(Model):\n    # Required field\n    name: str\n\n    # Optional field (nullable)\n    bio: str | None = Field(default=None)\n\n    # With default value\n    status: str = Field(default=\"active\")\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#type-mapping","title":"Type Mapping","text":"Python Type PostgreSQL SQLite MySQL <code>int</code> BIGINT INTEGER BIGINT <code>str</code> TEXT TEXT TEXT <code>float</code> DOUBLE PRECISION REAL DOUBLE <code>bool</code> BOOLEAN INTEGER TINYINT <code>datetime</code> TIMESTAMP TEXT DATETIME <code>date</code> DATE TEXT DATE <code>UUID</code> UUID TEXT CHAR(36) <code>Decimal</code> NUMERIC NUMERIC DECIMAL <code>bytes</code> BYTEA BLOB BLOB"},{"location":"guide/models/#primary-keys","title":"Primary Keys","text":""},{"location":"guide/models/#auto-increment-primary-key","title":"Auto-increment Primary Key","text":"<pre><code>class User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n\n    class Meta:\n        is_table = True\n</code></pre> <p>The <code>id</code> will be auto-generated on insert.</p>"},{"location":"guide/models/#uuid-primary-key","title":"UUID Primary Key","text":"<pre><code>from uuid import UUID, uuid4\n\nclass User(Model):\n    id: UUID = Field(default_factory=uuid4, db_pk=True)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#composite-primary-key","title":"Composite Primary Key","text":"<pre><code>class UserRole(Model):\n    user_id: int\n    role_id: int\n\n    class Meta:\n        is_table = True\n        primary_key = (\"user_id\", \"role_id\")\n</code></pre>"},{"location":"guide/models/#indexes","title":"Indexes","text":""},{"location":"guide/models/#single-column-index","title":"Single-Column Index","text":"<pre><code>class User(Model):\n    email: str = Field(db_index=True)\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#composite-index","title":"Composite Index","text":"<pre><code>from oxyde import Index\n\nclass Event(Model):\n    city: str\n    start_date: datetime\n\n    class Meta:\n        is_table = True\n        indexes = [\n            Index((\"city\", \"start_date\")),\n        ]\n</code></pre>"},{"location":"guide/models/#partial-index","title":"Partial Index","text":"<pre><code>class User(Model):\n    email: str\n    deleted_at: datetime | None = Field(default=None)\n\n    class Meta:\n        is_table = True\n        indexes = [\n            Index((\"email\",), unique=True, where=\"deleted_at IS NULL\"),\n        ]\n</code></pre>"},{"location":"guide/models/#index-methods","title":"Index Methods","text":"<p>PostgreSQL supports different index methods:</p> <pre><code>Index((\"data\",), method=\"gin\")   # GIN index for JSONB\nIndex((\"name\",), method=\"hash\")  # Hash index for equality\n</code></pre>"},{"location":"guide/models/#constraints","title":"Constraints","text":""},{"location":"guide/models/#unique-constraint","title":"UNIQUE Constraint","text":"<pre><code># Single column\nemail: str = Field(db_unique=True)\n\n# Multiple columns\nclass Meta:\n    unique_together = [(\"user_id\", \"slug\")]\n</code></pre>"},{"location":"guide/models/#check-constraint","title":"CHECK Constraint","text":"<pre><code>from oxyde import Check\n\nclass Event(Model):\n    start_date: datetime\n    end_date: datetime\n    price: float\n\n    class Meta:\n        is_table = True\n        constraints = [\n            Check(\"start_date &lt; end_date\", name=\"valid_dates\"),\n            Check(\"price &gt;= 0\"),\n        ]\n</code></pre>"},{"location":"guide/models/#sql-defaults","title":"SQL Defaults","text":"<p>Set database-level default values:</p> <pre><code>class User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n    uuid: str = Field(db_default=\"gen_random_uuid()\")  # PostgreSQL\n    status: str = Field(db_default=\"'active'\")  # Note: strings need quotes\n\n    class Meta:\n        is_table = True\n</code></pre> <p>Python vs SQL Defaults</p> <ul> <li><code>default=value</code> \u2014 Python-side default, used when creating instances</li> <li><code>db_default=\"...\"</code> \u2014 SQL-side default, used by the database</li> </ul>"},{"location":"guide/models/#column-mapping","title":"Column Mapping","text":"<p>Override the database column name:</p> <pre><code>class User(Model):\n    created_at: datetime = Field(db_column=\"created_timestamp\")\n\n    class Meta:\n        is_table = True\n</code></pre> <p>The Python attribute is <code>created_at</code>, but the database column is <code>created_timestamp</code>.</p>"},{"location":"guide/models/#custom-sql-types","title":"Custom SQL Types","text":"<p>Override the inferred SQL type:</p> <pre><code>class User(Model):\n    id: int = Field(db_pk=True, db_type=\"BIGSERIAL\")\n    name: str = Field(db_type=\"VARCHAR(255)\")\n    data: dict = Field(db_type=\"JSONB\")  # PostgreSQL\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#instance-methods","title":"Instance Methods","text":""},{"location":"guide/models/#save","title":"save()","text":"<p>Insert or update a record:</p> <pre><code># Insert new record\nuser = User(name=\"Alice\", email=\"alice@example.com\")\nawait user.save()\nprint(user.id)  # Auto-generated ID\n\n# Update existing record\nuser.name = \"Alice Smith\"\nawait user.save()\n\n# Partial update (only specified fields)\nuser.age = 31\nawait user.save(update_fields=[\"age\"])\n</code></pre>"},{"location":"guide/models/#delete","title":"delete()","text":"<p>Delete a record:</p> <pre><code>user = await User.objects.get(id=1)\nawait user.delete()\n</code></pre>"},{"location":"guide/models/#refresh","title":"refresh()","text":"<p>Reload from database:</p> <pre><code>user = await User.objects.get(id=1)\n# ... some other process updates the database ...\nawait user.refresh()  # Reload latest data\n</code></pre>"},{"location":"guide/models/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Override these methods to run code before/after database operations:</p> <pre><code>class User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    email: str\n    created_at: datetime | None = Field(default=None)\n    updated_at: datetime | None = Field(default=None)\n\n    class Meta:\n        is_table = True\n\n    async def pre_save(self, *, is_create: bool, update_fields: list[str] | None = None):\n        \"\"\"Called before save().\"\"\"\n        from datetime import datetime\n        now = datetime.utcnow()\n        if is_create:\n            self.created_at = now\n        self.updated_at = now\n\n    async def post_save(self, *, is_create: bool, update_fields: list[str] | None = None):\n        \"\"\"Called after save().\"\"\"\n        if is_create:\n            print(f\"Created user {self.id}\")\n\n    async def pre_delete(self):\n        \"\"\"Called before delete().\"\"\"\n        print(f\"About to delete user {self.id}\")\n\n    async def post_delete(self):\n        \"\"\"Called after delete().\"\"\"\n        print(f\"Deleted user {self.id}\")\n</code></pre>"},{"location":"guide/models/#model-inheritance","title":"Model Inheritance","text":""},{"location":"guide/models/#abstract-models","title":"Abstract Models","text":"<p>Create base models without database tables:</p> <pre><code>class TimestampMixin(Model):\n    \"\"\"Mixin for created_at/updated_at fields.\"\"\"\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n    updated_at: datetime | None = Field(default=None)\n\n\nclass User(TimestampMixin):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n\n    class Meta:\n        is_table = True\n</code></pre> <p>Only <code>User</code> creates a database table.</p>"},{"location":"guide/models/#pydantic-integration","title":"Pydantic Integration","text":"<p>Model inherits from Pydantic's BaseModel, so you get:</p>"},{"location":"guide/models/#validation","title":"Validation","text":"<pre><code>class User(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    age: int = Field(ge=0, le=150)  # Must be 0-150\n    email: str = Field(pattern=r\"^[\\w.-]+@[\\w.-]+\\.\\w+$\")\n\n    class Meta:\n        is_table = True\n\n# Raises ValidationError\nuser = User(age=200, email=\"invalid\")\n</code></pre>"},{"location":"guide/models/#serialization","title":"Serialization","text":"<pre><code>user = await User.objects.get(id=1)\n\n# To dict\ndata = user.model_dump()\n\n# To JSON\njson_str = user.model_dump_json()\n\n# From dict\nuser = User.model_validate({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n</code></pre>"},{"location":"guide/models/#json-aliases","title":"JSON Aliases","text":"<pre><code>class User(Model):\n    created_at: datetime = Field(\n        alias=\"createdAt\",        # JSON key\n        db_column=\"created_at\",   # Database column\n    )\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/models/#next-steps","title":"Next Steps","text":"<ul> <li>Fields \u2014 Complete field reference</li> <li>Queries \u2014 Query your models</li> <li>Relations \u2014 Foreign keys and joins</li> </ul>"},{"location":"guide/queries/","title":"Queries","text":"<p>Oxyde uses a Django-style QuerySet API for database queries.</p>"},{"location":"guide/queries/#query-builder-pattern","title":"Query Builder Pattern","text":"<p>Queries are built by chaining methods. The query executes when you call a terminal method like <code>all()</code> or <code>get()</code>.</p> <pre><code># Build query (not executed yet)\nquery = User.objects.filter(status=\"active\").order_by(\"-created_at\").limit(10)\n\n# Execute query\nusers = await query.all()\n</code></pre>"},{"location":"guide/queries/#the-manager-modelobjects","title":"The Manager: Model.objects","text":"<p>Every model has an <code>objects</code> manager:</p> <pre><code>class User(Model):\n    # ... fields ...\n\n    class Meta:\n        is_table = True\n\n# Access via Model.objects\nusers = await User.objects.all()\n</code></pre>"},{"location":"guide/queries/#query-methods","title":"Query Methods","text":""},{"location":"guide/queries/#retrieving-objects","title":"Retrieving Objects","text":""},{"location":"guide/queries/#all","title":"all()","text":"<p>Get all records:</p> <pre><code>users = await User.objects.all()\n</code></pre> <p>With filters:</p> <pre><code>active_users = await User.objects.filter(status=\"active\").all()\n</code></pre>"},{"location":"guide/queries/#get","title":"get()","text":"<p>Get exactly one record (raises exception if not found or multiple found):</p> <pre><code>from oxyde.exceptions import NotFoundError, MultipleObjectsReturned\n\ntry:\n    user = await User.objects.get(id=1)\nexcept NotFoundError:\n    print(\"User not found\")\nexcept MultipleObjectsReturned:\n    print(\"Multiple users found\")\n</code></pre>"},{"location":"guide/queries/#get_or_none","title":"get_or_none()","text":"<p>Get one record or None:</p> <pre><code>user = await User.objects.get_or_none(email=\"alice@example.com\")\nif user:\n    print(f\"Found: {user.name}\")\n</code></pre>"},{"location":"guide/queries/#first-last","title":"first() / last()","text":"<p>Get first or last record by primary key:</p> <pre><code>first_user = await User.objects.first()\nlast_user = await User.objects.last()\n</code></pre> <p>With filters (use limit):</p> <pre><code>users = await User.objects.filter(status=\"active\").order_by(\"-created_at\").limit(1).all()\nnewest_active = users[0] if users else None\n</code></pre>"},{"location":"guide/queries/#filtering","title":"Filtering","text":""},{"location":"guide/queries/#filter","title":"filter()","text":"<p>Add WHERE conditions (AND):</p> <pre><code># Simple equality\nusers = await User.objects.filter(status=\"active\").all()\n\n# Multiple conditions (AND)\nusers = await User.objects.filter(status=\"active\", age__gte=18).all()\n\n# Chained filters (also AND)\nusers = await User.objects.filter(status=\"active\").filter(age__gte=18).all()\n</code></pre>"},{"location":"guide/queries/#exclude","title":"exclude()","text":"<p>Exclude matching records:</p> <pre><code># NOT status = 'banned'\nusers = await User.objects.exclude(status=\"banned\").all()\n\n# Combine with filter\nusers = await User.objects.filter(age__gte=18).exclude(role=\"bot\").all()\n</code></pre> <p>See Filtering for complete lookup reference.</p>"},{"location":"guide/queries/#ordering","title":"Ordering","text":""},{"location":"guide/queries/#order_by","title":"order_by()","text":"<p>Sort results:</p> <pre><code># Ascending\nusers = await User.objects.order_by(\"name\").all()\n\n# Descending (prefix with -)\nusers = await User.objects.order_by(\"-created_at\").all()\n\n# Multiple columns\nusers = await User.objects.order_by(\"status\", \"-created_at\").all()\n</code></pre>"},{"location":"guide/queries/#pagination","title":"Pagination","text":""},{"location":"guide/queries/#limit-offset","title":"limit() / offset()","text":"<pre><code># First 10 records\nusers = await User.objects.limit(10).all()\n\n# Skip 20, take 10 (pagination)\nusers = await User.objects.offset(20).limit(10).all()\n</code></pre>"},{"location":"guide/queries/#selecting-fields","title":"Selecting Fields","text":""},{"location":"guide/queries/#values","title":"values()","text":"<p>Return dictionaries instead of model instances:</p> <pre><code># Select specific fields\nusers = await User.objects.values(\"id\", \"email\").all()\n# [{\"id\": 1, \"email\": \"alice@example.com\"}, ...]\n</code></pre>"},{"location":"guide/queries/#values_list","title":"values_list()","text":"<p>Return tuples:</p> <pre><code># As tuples\nusers = await User.objects.values_list(\"id\", \"email\").all()\n# [(1, \"alice@example.com\"), ...]\n\n# Flat list (single field only)\nids = await User.objects.values_list(\"id\", flat=True).all()\n# [1, 2, 3, ...]\n</code></pre>"},{"location":"guide/queries/#distinct","title":"distinct()","text":"<p>Remove duplicates:</p> <pre><code>cities = await User.objects.values(\"city\").distinct().all()\n</code></pre>"},{"location":"guide/queries/#aggregation","title":"Aggregation","text":""},{"location":"guide/queries/#count","title":"count()","text":"<pre><code>count = await User.objects.count()\ncount = await User.objects.filter(status=\"active\").count()\n</code></pre>"},{"location":"guide/queries/#sum-avg-max-min","title":"sum() / avg() / max() / min()","text":"<pre><code>total = await Order.objects.sum(\"amount\")\naverage = await User.objects.avg(\"age\")\nhighest = await Product.objects.max(\"price\")\nlowest = await Product.objects.min(\"price\")\n</code></pre> <p>See Aggregation for GROUP BY and HAVING.</p>"},{"location":"guide/queries/#existence-check","title":"Existence Check","text":""},{"location":"guide/queries/#exists","title":"exists()","text":"<pre><code>has_admins = await User.objects.filter(role=\"admin\").exists()\nif has_admins:\n    print(\"At least one admin exists\")\n</code></pre>"},{"location":"guide/queries/#creating-records","title":"Creating Records","text":""},{"location":"guide/queries/#create","title":"create()","text":"<pre><code>user = await User.objects.create(\n    name=\"Alice\",\n    email=\"alice@example.com\",\n    age=30\n)\nprint(user.id)  # Auto-generated\n</code></pre>"},{"location":"guide/queries/#bulk_create","title":"bulk_create()","text":"<p>Insert multiple records efficiently:</p> <pre><code>users = [\n    User(name=\"Alice\", email=\"alice@example.com\"),\n    User(name=\"Bob\", email=\"bob@example.com\"),\n    User(name=\"Carol\", email=\"carol@example.com\"),\n]\ncreated = await User.objects.bulk_create(users)\n</code></pre> <p>With batching:</p> <pre><code># Insert in batches of 100\ncreated = await User.objects.bulk_create(users, batch_size=100)\n</code></pre>"},{"location":"guide/queries/#get_or_create","title":"get_or_create()","text":"<p>Get existing or create new:</p> <pre><code>user, created = await User.objects.get_or_create(\n    email=\"alice@example.com\",\n    defaults={\"name\": \"Alice\", \"age\": 30}\n)\nif created:\n    print(\"Created new user\")\nelse:\n    print(\"Found existing user\")\n</code></pre>"},{"location":"guide/queries/#updating-records","title":"Updating Records","text":""},{"location":"guide/queries/#update","title":"update()","text":"<p>Bulk update matching records:</p> <pre><code># Returns list of updated rows (RETURNING *)\nrows = await User.objects.filter(status=\"pending\").update(status=\"active\")\nprint(f\"Updated {len(rows)} users\")\n</code></pre> <p>With F expressions:</p> <pre><code>from oxyde import F\n\n# Atomic increment\nawait Post.objects.filter(id=1).update(views=F(\"views\") + 1)\n</code></pre>"},{"location":"guide/queries/#bulk_update","title":"bulk_update()","text":"<p>Update multiple model instances:</p> <pre><code>users = await User.objects.filter(status=\"pending\").all()\nfor user in users:\n    user.status = \"active\"\n\ncount = await User.objects.bulk_update(users, [\"status\"])\n</code></pre>"},{"location":"guide/queries/#increment","title":"increment()","text":"<p>Atomic field increment:</p> <pre><code>await Post.objects.filter(id=1).increment(\"views\", by=1)\nawait Product.objects.filter(id=1).increment(\"stock\", by=-1)  # Decrement\n</code></pre>"},{"location":"guide/queries/#deleting-records","title":"Deleting Records","text":""},{"location":"guide/queries/#delete","title":"delete()","text":"<p>Bulk delete matching records:</p> <pre><code>count = await User.objects.filter(status=\"deleted\").delete()\n</code></pre>"},{"location":"guide/queries/#joins","title":"Joins","text":""},{"location":"guide/queries/#join","title":"join()","text":"<p>Eager load related models:</p> <pre><code># Load author with each post\nposts = await Post.objects.join(\"author\").all()\nfor post in posts:\n    print(f\"{post.title} by {post.author.name}\")\n</code></pre>"},{"location":"guide/queries/#prefetch","title":"prefetch()","text":"<p>Load reverse relations:</p> <pre><code># Load posts for each author\nauthors = await Author.objects.prefetch(\"posts\").all()\nfor author in authors:\n    print(f\"{author.name} has {len(author.posts)} posts\")\n</code></pre> <p>See Relations for more.</p>"},{"location":"guide/queries/#locking","title":"Locking","text":""},{"location":"guide/queries/#for_update","title":"for_update()","text":"<p>Lock rows for update (PostgreSQL/MySQL):</p> <pre><code>from oxyde.db import transaction\n\nasync with transaction.atomic():\n    user = await User.objects.filter(id=1).for_update().first()\n    user.balance -= 100\n    await user.save()\n</code></pre>"},{"location":"guide/queries/#for_share","title":"for_share()","text":"<p>Lock rows for reading:</p> <pre><code>async with transaction.atomic():\n    users = await User.objects.filter(status=\"active\").for_share().all()\n</code></pre>"},{"location":"guide/queries/#union","title":"Union","text":"<p>Combine query results:</p> <pre><code>admins = User.objects.filter(role=\"admin\")\nmoderators = User.objects.filter(role=\"moderator\")\n\n# UNION (distinct)\nstaff = await admins.union(moderators).all()\n\n# UNION ALL (keep duplicates)\nall_staff = await admins.union_all(moderators).all()\n</code></pre>"},{"location":"guide/queries/#debugging","title":"Debugging","text":""},{"location":"guide/queries/#sql","title":"sql()","text":"<p>Get generated SQL:</p> <pre><code>query = User.objects.filter(age__gte=18).limit(10)\nsql, params = query.sql()\nprint(f\"SQL: {sql}\")\nprint(f\"Params: {params}\")\n</code></pre> <p>With specific dialect:</p> <pre><code>sql, params = query.sql(dialect=\"postgres\")\n</code></pre>"},{"location":"guide/queries/#explain","title":"explain()","text":"<p>Get query plan:</p> <pre><code>plan = await User.objects.filter(age__gte=18).explain()\nprint(plan)\n\n# With actual execution times\nplan = await User.objects.filter(age__gte=18).explain(analyze=True)\n</code></pre>"},{"location":"guide/queries/#query-immutability","title":"Query Immutability","text":"<p>Queries are immutable. Each method returns a new query:</p> <pre><code>base = User.objects.filter(status=\"active\")\nadmins = base.filter(role=\"admin\")    # base is unchanged\nusers = base.filter(role=\"user\")      # base is unchanged\n\n# base, admins, and users are different queries\n</code></pre>"},{"location":"guide/queries/#specifying-database","title":"Specifying Database","text":"<p>Use <code>using</code> parameter to specify which database:</p> <pre><code># Default database\nusers = await User.objects.all()\n\n# Specific database\nusers = await User.objects.all(using=\"analytics\")\n</code></pre>"},{"location":"guide/queries/#next-steps","title":"Next Steps","text":"<ul> <li>Filtering \u2014 Complete lookup reference</li> <li>Expressions \u2014 F expressions for database operations</li> <li>Aggregation \u2014 GROUP BY and aggregate functions</li> </ul>"},{"location":"guide/relations/","title":"Relations","text":"<p>Oxyde supports foreign key relationships and eager loading.</p>"},{"location":"guide/relations/#foreign-keys","title":"Foreign Keys","text":""},{"location":"guide/relations/#defining-a-foreign-key","title":"Defining a Foreign Key","text":"<p>Foreign keys are defined using type annotations:</p> <pre><code>class Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n    class Meta:\n        is_table = True\n</code></pre> <p>This creates: - A column <code>author_id</code> in the database - A foreign key constraint to <code>Author.id</code></p>"},{"location":"guide/relations/#working-with-foreign-keys","title":"Working with Foreign Keys","text":"<pre><code># Create with FK ID\npost = await Post.objects.create(\n    title=\"Hello World\",\n    author_id=1  # Use the _id suffix\n)\n\n# Access FK value\nprint(post.author_id)  # 1\n</code></pre>"},{"location":"guide/relations/#fk-to-non-pk-field","title":"FK to Non-PK Field","text":"<p>Reference a different field:</p> <pre><code>class Resource(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    tenant: \"Tenant\" | None = Field(\n        default=None,\n        db_fk=\"uuid\",  # Target Tenant.uuid instead of Tenant.id\n        db_on_delete=\"CASCADE\"\n    )\n\n    class Meta:\n        is_table = True\n</code></pre> <p>This creates column <code>tenant_uuid</code> referencing <code>Tenant.uuid</code>.</p>"},{"location":"guide/relations/#on-delete-actions","title":"ON DELETE Actions","text":"Action Description <code>CASCADE</code> Delete related rows <code>SET NULL</code> Set FK to NULL <code>RESTRICT</code> Prevent deletion <code>NO ACTION</code> Deferred check <pre><code># CASCADE - delete posts when author deleted\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n# SET NULL - keep post, set author to NULL\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"SET NULL\")\n\n# RESTRICT - prevent deletion if posts exist\nauthor: \"Author\" | None = Field(default=None, db_on_delete=\"RESTRICT\")\n</code></pre>"},{"location":"guide/relations/#eager-loading","title":"Eager Loading","text":""},{"location":"guide/relations/#join","title":"join()","text":"<p>Load related models in a single query (LEFT JOIN):</p> <pre><code># Load author with each post\nposts = await Post.objects.join(\"author\").all()\n\nfor post in posts:\n    print(f\"{post.title} by {post.author.name}\")\n</code></pre> <p>Without <code>join()</code>, accessing <code>post.author</code> would require another query.</p>"},{"location":"guide/relations/#multiple-joins","title":"Multiple Joins","text":"<pre><code>posts = await Post.objects.join(\"author\", \"category\").all()\n</code></pre>"},{"location":"guide/relations/#nested-joins","title":"Nested Joins","text":"<p>Use <code>__</code> to traverse relations:</p> <pre><code># Post -&gt; Author -&gt; Company\nposts = await Post.objects.join(\"author__company\").all()\nfor post in posts:\n    print(f\"{post.title} by {post.author.name} at {post.author.company.name}\")\n</code></pre>"},{"location":"guide/relations/#reverse-relations","title":"Reverse Relations","text":""},{"location":"guide/relations/#defining-reverse-fk","title":"Defining Reverse FK","text":"<p>On the \"one\" side of a one-to-many:</p> <pre><code>class Author(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    posts: list[\"Post\"] = Field(db_reverse_fk=\"author\")  # Virtual field for reverse relation\n\n    class Meta:\n        is_table = True\n\n\nclass Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/relations/#prefetch","title":"prefetch()","text":"<p>Load reverse relations:</p> <pre><code># Load all posts for each author\nauthors = await Author.objects.prefetch(\"posts\").all()\n\nfor author in authors:\n    print(f\"{author.name} has {len(author.posts)} posts\")\n    for post in author.posts:\n        print(f\"  - {post.title}\")\n</code></pre> <p><code>prefetch()</code> executes a separate query and attaches results.</p>"},{"location":"guide/relations/#many-to-many","title":"Many-to-Many","text":""},{"location":"guide/relations/#defining-m2m","title":"Defining M2M","text":"<p>Use a junction table:</p> <pre><code>class Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    tags: list[\"Tag\"] = Field(db_m2m=True, db_through=\"PostTag\")\n\n    class Meta:\n        is_table = True\n\n\nclass Tag(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str = Field(db_unique=True)\n\n    class Meta:\n        is_table = True\n\n\nclass PostTag(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    post: \"Post\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n    tag: \"Tag\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/relations/#working-with-m2m","title":"Working with M2M","text":"<p>M2M relations are supported by <code>prefetch()</code>. The through model must have FK fields to both models:</p> <pre><code># Load posts with their tags\nposts = await Post.objects.prefetch(\"tags\").all()\nfor post in posts:\n    print(f\"{post.title}: {[t.name for t in post.tags]}\")\n</code></pre> <p>You can also work with the junction table directly:</p> <pre><code># Add tag to post\nawait PostTag.objects.create(post_id=post.id, tag_id=tag.id)\n\n# Remove tag from post\nawait PostTag.objects.filter(post_id=post.id, tag_id=tag.id).delete()\n\n# Get all tags for a post (alternative approach)\npost_tags = await PostTag.objects.filter(post_id=post.id).join(\"tag\").all()\ntags = [pt.tag for pt in post_tags]\n</code></pre>"},{"location":"guide/relations/#automatic-fk-column-naming","title":"Automatic FK Column Naming","text":"<p>Oxyde automatically creates FK columns:</p> Field Definition Created Column <code>author: Author</code> <code>author_id</code> <code>author: Author</code> (PK is <code>uuid</code>) <code>author_uuid</code> <code>category: Category</code> (FK to <code>code</code>) <code>category_code</code>"},{"location":"guide/relations/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/relations/#self-referential-fk","title":"Self-Referential FK","text":"<pre><code>class Category(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    parent: \"Category\" | None = Field(default=None, db_on_delete=\"SET NULL\")\n\n    class Meta:\n        is_table = True\n</code></pre>"},{"location":"guide/relations/#polymorphic-relations-manual","title":"Polymorphic Relations (Manual)","text":"<pre><code>class Comment(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    content: str\n    commentable_type: str  # \"post\" or \"photo\"\n    commentable_id: int\n\n    class Meta:\n        is_table = True\n\n# Query\npost_comments = await Comment.objects.filter(\n    commentable_type=\"post\",\n    commentable_id=post_id\n).all()\n</code></pre>"},{"location":"guide/relations/#soft-delete-with-relations","title":"Soft Delete with Relations","text":"<pre><code>class Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    deleted_at: datetime | None = Field(default=None)\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"SET NULL\")\n\n    class Meta:\n        is_table = True\n\n# Query active posts with author\nposts = await Post.objects.filter(\n    deleted_at__isnull=True\n).join(\"author\").all()\n</code></pre>"},{"location":"guide/relations/#complete-example","title":"Complete Example","text":"<pre><code>from datetime import datetime\nfrom oxyde import Model, Field, db\n\nclass Author(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    posts: list[\"Post\"] = Field(db_reverse_fk=\"author\")\n\n    class Meta:\n        is_table = True\n        table_name = \"authors\"\n\n\nclass Post(Model):\n    id: int | None = Field(default=None, db_pk=True)\n    title: str\n    content: str\n    author: \"Author\" | None = Field(default=None, db_on_delete=\"CASCADE\")\n    created_at: datetime = Field(db_default=\"CURRENT_TIMESTAMP\")\n\n    class Meta:\n        is_table = True\n        table_name = \"posts\"\n\n\nasync def main():\n    async with db.connect(\"sqlite:///blog.db\"):\n        # Create author\n        author = await Author.objects.create(name=\"Alice\")\n\n        # Create posts\n        await Post.objects.create(\n            title=\"First Post\",\n            content=\"Hello!\",\n            author_id=author.id\n        )\n        await Post.objects.create(\n            title=\"Second Post\",\n            content=\"World!\",\n            author_id=author.id\n        )\n\n        # Load posts with author (JOIN)\n        posts = await Post.objects.join(\"author\").all()\n        for post in posts:\n            print(f\"{post.title} by {post.author.name}\")\n\n        # Load author with posts (prefetch)\n        authors = await Author.objects.prefetch(\"posts\").all()\n        for author in authors:\n            print(f\"{author.name}: {len(author.posts)} posts\")\n</code></pre>"},{"location":"guide/relations/#limitations","title":"Limitations","text":""},{"location":"guide/relations/#no-m2m-in-join","title":"No M2M in join()","text":"<p>M2M relations are supported by <code>prefetch()</code> but not by <code>join()</code>. Use <code>prefetch()</code> for M2M.</p>"},{"location":"guide/relations/#next-steps","title":"Next Steps","text":"<ul> <li>Transactions \u2014 Atomic operations</li> <li>Queries \u2014 Full query reference</li> <li>Fields \u2014 Field options reference</li> </ul>"},{"location":"guide/transactions/","title":"Transactions","text":"<p>Oxyde provides Django-style transaction management with the <code>transaction.atomic()</code> context manager.</p>"},{"location":"guide/transactions/#basic-usage","title":"Basic Usage","text":"<pre><code>from oxyde.db import transaction\n\nasync with transaction.atomic():\n    user = await User.objects.create(name=\"Alice\")\n    await Profile.objects.create(user_id=user.id)\n    # Commits automatically on exit\n</code></pre> <p>If an exception occurs, the transaction rolls back:</p> <pre><code>async with transaction.atomic():\n    user = await User.objects.create(name=\"Alice\")\n    raise ValueError(\"Something went wrong\")\n    # Transaction rolled back - user not created\n</code></pre>"},{"location":"guide/transactions/#nested-transactions-savepoints","title":"Nested Transactions (Savepoints)","text":"<p>Nested <code>transaction.atomic()</code> blocks create savepoints:</p> <pre><code>async with transaction.atomic():\n    user = await User.objects.create(name=\"Alice\")\n\n    try:\n        async with transaction.atomic():  # Creates savepoint\n            await Post.objects.create(author_id=user.id, title=\"Test\")\n            raise ValueError(\"Rollback inner only\")\n    except ValueError:\n        pass  # Inner transaction rolled back\n\n    # User still created - only post was rolled back\n    # Outer transaction commits\n</code></pre>"},{"location":"guide/transactions/#manual-rollback","title":"Manual Rollback","text":"<p>Force rollback without an exception:</p> <pre><code>async with transaction.atomic() as tx:\n    await User.objects.create(name=\"Alice\")\n\n    if some_condition:\n        tx.set_rollback(True)  # Mark for rollback\n    # Transaction will rollback even without exception\n</code></pre>"},{"location":"guide/transactions/#transaction-timeout","title":"Transaction Timeout","text":"<p>Set a timeout for long-running transactions:</p> <pre><code>from oxyde.db import transaction, TransactionTimeoutError\n\ntry:\n    async with transaction.atomic(timeout=30):  # 30 seconds\n        await slow_operation()\nexcept TransactionTimeoutError:\n    print(\"Transaction timed out\")\n</code></pre>"},{"location":"guide/transactions/#specifying-database","title":"Specifying Database","text":"<p>Use transactions on a specific database:</p> <pre><code>async with transaction.atomic(using=\"analytics\"):\n    await Event.objects.create(type=\"signup\")\n</code></pre>"},{"location":"guide/transactions/#row-locking","title":"Row Locking","text":"<p>Lock rows for update within a transaction:</p> <pre><code>async with transaction.atomic():\n    # SELECT ... FOR UPDATE\n    user = await User.objects.filter(id=1).for_update().first()\n    user.balance -= 100\n    await user.save()\n</code></pre> <p>Or for read-only locks:</p> <pre><code>async with transaction.atomic():\n    # SELECT ... FOR SHARE\n    users = await User.objects.filter(status=\"active\").for_share().all()\n</code></pre> <p>SQLite</p> <p>SQLite uses database-level locking. <code>for_update()</code> and <code>for_share()</code> are no-ops on SQLite.</p>"},{"location":"guide/transactions/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/transactions/#transfer-money","title":"Transfer Money","text":"<pre><code>from oxyde import F\nfrom oxyde.db import transaction\n\nasync def transfer(from_id: int, to_id: int, amount: float):\n    async with transaction.atomic():\n        # Lock both accounts\n        from_acc = await Account.objects.filter(id=from_id).for_update().first()\n        to_acc = await Account.objects.filter(id=to_id).for_update().first()\n\n        if from_acc.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        await Account.objects.filter(id=from_id).update(\n            balance=F(\"balance\") - amount\n        )\n        await Account.objects.filter(id=to_id).update(\n            balance=F(\"balance\") + amount\n        )\n</code></pre>"},{"location":"guide/transactions/#create-with-related-objects","title":"Create with Related Objects","text":"<pre><code>async def create_user_with_profile(name: str, email: str, bio: str):\n    async with transaction.atomic():\n        user = await User.objects.create(name=name, email=email)\n        await Profile.objects.create(user_id=user.id, bio=bio)\n        return user\n</code></pre>"},{"location":"guide/transactions/#bulk-operations","title":"Bulk Operations","text":"<pre><code>async def import_users(data: list[dict]):\n    async with transaction.atomic():\n        for item in data:\n            await User.objects.create(**item)\n        # All or nothing - rolls back if any fails\n</code></pre>"},{"location":"guide/transactions/#conditional-rollback","title":"Conditional Rollback","text":"<pre><code>async def process_order(order_id: int):\n    async with transaction.atomic() as tx:\n        order = await Order.objects.get(id=order_id)\n\n        if order.status != \"pending\":\n            tx.set_rollback(True)\n            return None\n\n        await order.process()\n        order.status = \"completed\"\n        await order.save()\n        return order\n</code></pre>"},{"location":"guide/transactions/#retry-on-conflict","title":"Retry on Conflict","text":"<pre><code>async def increment_with_retry(user_id: int, max_retries: int = 3):\n    for attempt in range(max_retries):\n        try:\n            async with transaction.atomic():\n                user = await User.objects.filter(id=user_id).for_update().first()\n                user.counter += 1\n                await user.save()\n                return\n        except Exception:\n            if attempt == max_retries - 1:\n                raise\n            await asyncio.sleep(0.1 * (attempt + 1))\n</code></pre>"},{"location":"guide/transactions/#pool-level-transaction-cleanup","title":"Pool-Level Transaction Cleanup","text":"<p>Configure automatic cleanup of leaked transactions:</p> <pre><code>from oxyde import AsyncDatabase, PoolSettings\n\ndb = AsyncDatabase(\n    \"postgresql://localhost/mydb\",\n    settings=PoolSettings(\n        transaction_timeout=300,           # 5 minutes max\n        transaction_cleanup_interval=60,   # Check every minute\n    )\n)\n</code></pre> <p>Transactions exceeding the timeout are automatically rolled back.</p>"},{"location":"guide/transactions/#recommended-timeouts","title":"Recommended Timeouts","text":"Workload Timeout Cleanup Interval Web API 5 min 1 min Background Jobs 30 min 5 min Data Analytics 60 min 10 min Migrations 2 hours 10 min"},{"location":"guide/transactions/#exceptions","title":"Exceptions","text":"<pre><code>from oxyde.db import transaction, TransactionTimeoutError\n\ntry:\n    async with transaction.atomic(timeout=10):\n        await long_running_operation()\nexcept TransactionTimeoutError:\n    print(\"Transaction exceeded timeout\")\n</code></pre>"},{"location":"guide/transactions/#best-practices","title":"Best Practices","text":""},{"location":"guide/transactions/#1-keep-transactions-short","title":"1. Keep Transactions Short","text":"<pre><code># GOOD: Short transaction\nasync with transaction.atomic():\n    user = await User.objects.get(id=1)\n    user.status = \"active\"\n    await user.save()\n\n# BAD: Long transaction with external calls\nasync with transaction.atomic():\n    user = await User.objects.get(id=1)\n    await send_email(user)  # External call inside transaction!\n    user.notified = True\n    await user.save()\n</code></pre>"},{"location":"guide/transactions/#2-dont-nest-unnecessarily","title":"2. Don't Nest Unnecessarily","text":"<pre><code># GOOD: Single transaction\nasync with transaction.atomic():\n    await create_user()\n    await create_profile()\n\n# UNNECESSARY: Nested transactions\nasync with transaction.atomic():\n    async with transaction.atomic():  # Extra savepoint overhead\n        await create_user()\n    async with transaction.atomic():\n        await create_profile()\n</code></pre>"},{"location":"guide/transactions/#3-handle-errors-appropriately","title":"3. Handle Errors Appropriately","text":"<pre><code># GOOD: Let exceptions propagate\nasync with transaction.atomic():\n    await risky_operation()\n    # Exception rolls back transaction\n\n# GOOD: Handle specific cases\nasync with transaction.atomic():\n    try:\n        await risky_operation()\n    except SpecificError:\n        # Handle but still commit other work\n        pass\n</code></pre>"},{"location":"guide/transactions/#4-use-appropriate-isolation","title":"4. Use Appropriate Isolation","text":"<pre><code># Use FOR UPDATE when modifying shared data\nasync with transaction.atomic():\n    account = await Account.objects.filter(id=1).for_update().first()\n    account.balance -= 100\n    await account.save()\n</code></pre>"},{"location":"guide/transactions/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom oxyde import Model, Field, db, F\nfrom oxyde.db import transaction, TransactionTimeoutError\n\nclass Account(Model):\n    class Meta:\n        is_table = True\n\n    id: int | None = Field(default=None, db_pk=True)\n    name: str\n    balance: float = Field(default=0)\n\nasync def transfer(from_id: int, to_id: int, amount: float) -&gt; bool:\n    \"\"\"Transfer money between accounts atomically.\"\"\"\n    try:\n        async with transaction.atomic(timeout=30):\n            # Lock accounts to prevent concurrent modifications\n            from_acc = await Account.objects.filter(id=from_id).for_update().first()\n            to_acc = await Account.objects.filter(id=to_id).for_update().first()\n\n            if not from_acc or not to_acc:\n                return False\n\n            if from_acc.balance &lt; amount:\n                return False\n\n            # Update balances atomically\n            await Account.objects.filter(id=from_id).update(\n                balance=F(\"balance\") - amount\n            )\n            await Account.objects.filter(id=to_id).update(\n                balance=F(\"balance\") + amount\n            )\n\n            return True\n\n    except TransactionTimeoutError:\n        print(\"Transfer timed out\")\n        return False\n\nasync def main():\n    async with db.connect(\"sqlite:///bank.db\"):\n        # Create accounts\n        alice = await Account.objects.create(name=\"Alice\", balance=1000)\n        bob = await Account.objects.create(name=\"Bob\", balance=500)\n\n        # Transfer money\n        success = await transfer(alice.id, bob.id, 200)\n        print(f\"Transfer successful: {success}\")\n\n        # Check balances\n        alice = await Account.objects.get(id=alice.id)\n        bob = await Account.objects.get(id=bob.id)\n        print(f\"Alice: ${alice.balance}, Bob: ${bob.balance}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/transactions/#next-steps","title":"Next Steps","text":"<ul> <li>Migrations \u2014 Database migrations</li> <li>Performance \u2014 Performance optimization</li> <li>Connections \u2014 Connection management</li> </ul>"}]}